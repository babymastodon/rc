" tabs are saved as spaces
set expandtab

" let netrw manage cwd
set noautochdir
let g:netrw_keepdir = 0
augroup AutoChdirFiles
  autocmd!
  autocmd BufEnter * if &buftype == '' && !isdirectory(expand('%'))
        \ | set autochdir
        \ | else
        \ | set noautochdir
        \ | endif
augroup END


" default tab widths
set bs=2
set tabstop=2
set shiftwidth=2

" smartindent only good for C
set nosmartindent
set autoindent

" specific tab widths
au FileType python setl sw=4 sts=4 et
au FileType mcs51a setl sw=3 sts=3 et

" stick to the color pallette
set notermguicolors     " disable truecolor
set t_Co=16             " tell Vim we only have 16 colors

" enable vimrc line extensions
set nocompatible

" default fold level to syntax
" set foldmethod=syntax
" set foldlevelstart=10

" all folds open by default
autocmd BufWinEnter * let &foldlevel = max(map(range(1, line('$')), 'foldlevel(v:val)'))

" enable mouse
set mouse=a

" show netrw previews in vertically split window
let g:netrw_preview = 1

" Disable Ex Mode
:nnoremap Q <Nop>

" open file under cursor in vertical split
noremap gf :vertical wincmd F<CR>

" enable spellcheck
" set spell spelllang=en_us

" pressing F2 enters paste mode
set pastetoggle=<F2>

" F3: show hover/type info (YCMHover → Coc hover)
nnoremap <silent> <F3> :call CocActionAsync('doHover')<CR>

" Insert Ascii Text Headers
command! -nargs=* Header read !figlet -f starwars -k -w 60 -c <args>

" show whitespace
nnoremap S :set list!<CR>

" write to file
nnoremap W :w<CR>

" reload buffer
nnoremap E :edit!<CR>

" More intuitive movement
noremap H 10h
noremap L 10l
noremap <C-h> ^
noremap <C-l> $

noremap J 5j
noremap K 5k
noremap <C-j> 15<C-e>
noremap <C-k> 15<C-y>

" Map open directory to ctrl-d
nnoremap <C-d> :e .<CR>

" Splits open on the right
set splitright

" Files should be UTF-8 by default
set encoding=utf-8

" moar commands
:command! WQ wq
:command! Wq wq
:command! W w
:command! Q q
:command! Tabe tabe
:command! TAbe tabe
:command! TABe tabe
:command! TABE tabe

" Ctrl-t opens a new tab
:nnoremap <C-t>     :tab split<CR>
:inoremap <C-t>     <Esc>:tab split<CR>

" tagbar
nnoremap <F9> :TagbarToggle<CR>
let g:tagbar_width = 80
let g:tagbar_type_go = {
  \ 'ctagstype' : 'go',
  \ 'kinds'     : [
    \ 'p:package',
    \ 'i:imports:1',
    \ 'c:constants',
    \ 'v:variables',
    \ 't:types',
    \ 'n:interfaces',
    \ 'w:fields',
    \ 'e:embedded',
    \ 'm:methods',
    \ 'r:constructor',
    \ 'f:functions'
  \ ],
  \ 'sro' : '.',
  \ 'kind2scope' : {
    \ 't' : 'ctype',
    \ 'n' : 'ntype'
  \ },
  \ 'scope2kind' : {
    \ 'ctype' : 't',
    \ 'ntype' : 'n'
  \ },
  \ 'ctagsbin'  : 'gotags',
  \ 'ctagsargs' : '-sort -silent'
\ }

" format json
nnoremap gj :%!python -m json.tool<CR>

" enable python highlighting
let python_highlight_all=1

" quickfix and loclist
let g:lt_location_list_toggle_map = '<leader>l'
let g:lt_quickfix_list_toggle_map = '<leader>q'
let g:lt_height = 10
noremap - :cprev<CR>
noremap = :cnext<CR>


" go to first linter error, and iterate through the errors
:nnoremap ; :lfirst<CR>
:nnoremap + :lnext<CR>
:nnoremap _ :lprev<CR>
function! s:UpdateCocLoclistAll() abort
  " Get all diagnostics from coc.nvim
  let diagnostics = CocAction('diagnosticList')
  let items = []

  for d in diagnostics
    let sev = get(d, 'severity', '')
    let type = sev ==# 'Error' ? 'E'
          \ : sev ==# 'Warning' ? 'W'
          \ : 'I'

    call add(items, {
          \ 'filename': d.file,
          \ 'lnum': d.lnum,
          \ 'col': d.col + 1,
          \ 'text': d.message,
          \ 'type': type,
          \ })
  endfor

  " Replace location list contents without opening any window
  call setloclist(0, items, 'r')
endfunction

augroup CocLoclistAll
  autocmd!
  autocmd User CocDiagnosticChange call s:UpdateCocLoclistAll()
augroup END


" resize
" nnoremap + :exe "resize " . (winheight(0) * 3/2)<CR>
" nnoremap _ :exe "resize " . (winheight(0) * 2/3)<CR>

" go to next tag match
noremap ) :tn<CR>
noremap ( :tp<CR>

" autoload tag files
:set tags=./tags;
" jump backwards in the ctag stack
:nnoremap <C-p> <C-t>
" next/previous tag match
" NOTE: replaced with quicklist navigation
" :nnoremap + :tnext<CR>
" :nnoremap _ :tprevious<CR>

" disable preview split on autocomplete
:set completeopt-=preview

" --- Coc.nvim basic LSP/completion settings (replacement for YCM/ALE) ---
set completeopt+=menuone,noinsert,noselect
set updatetime=300
set shortmess+=c
set signcolumn=yes

" search and hilight word under cursor
nnoremap * :keepjumps normal! mi*`i<CR>

" enter joins selected lines in visual mode
vnoremap <C-m> :join<CR>

" 120 character line limit python
highlight OverLength ctermbg=green ctermfg=white
autocmd FileType python 2match OverLength /\%>120v.\+/

" Press F5 to toggle highlighting on/off, and show current value.
noremap <F5> :set hlsearch! hlsearch?<CR>
set hlsearch
set incsearch

" Press & to switch between two related files
au FileType cpp nnoremap & :e %:p:s,.h$,.X123X,:s,.cpp$,.h,:s,.X123X$,.cpp,<CR>
au FileType html nnoremap & :e %<.js<CR>
au FileType javascript nnoremap & :e %<.html<CR>
au FileType go nnoremap & :e %:p:s,\([^_][^t][^e][^s][^t]\).go$,\1.X123X,:s,_test.go$,.go,:s,.X123X$,_test.go,<CR>

" highlight trailing whitespace
highlight ExtraWhitespace ctermbg=green ctermbg=green
match ExtraWhitespace /\s\+$/
autocmd BufWinEnter * match ExtraWhitespace /\s\+$/
autocmd InsertEnter * match ExtraWhitespace /\s\+\%#\@<!$/
autocmd InsertLeave * match ExtraWhitespace /\s\+$/
autocmd BufWinLeave * call clearmatches()

" reset the tmux status line
augroup TmuxGitBadgeCleanup
  autocmd!
  autocmd BufWritePost * silent! call system('rm -f /tmp/tmux-badge-git*')
augroup END

" fix bug in go-vim syntax file
let go_highlight_trailing_whitespace_error = 0

" Coc-based goto def / FixIt (YCM → Coc)
nmap <silent> gd <Plug>(coc-definition)
nmap <silent> gl <Plug>(coc-codeaction-cursor)
set signcolumn=auto
nnoremap <silent> <F4> :CocRestart<CR>
nnoremap <silent> <leader>h :CocCommand document.toggleInlayHint<CR>

let g:go_fmt_experimental = 1
let g:go_fmt_fail_silently = 1
let g:go_doc_keywordprg_enabled = 0
let g:go_bin_path = expand("~/bin")
let g:go_oracle_include_tests = 1
let g:go_fmt_command = "goimports"
let g:go_def_mode = "godef"
let g:go_def_mapping_enabled=0

let g:ctrlp_map = '<C-n>'
let g:ctrlp_extensions = ['tag', 'dir']
let g:ctrlp_max_files=0
let g:ctrlp_max_depth=40
let g:ctrlp_regexp = 1
let g:ctrlp_switch_buffer=0
let g:ctrlp_user_command = { 'types': { 1: ['.git', 'cd %s && git ls-files'], 2: ['.hg', 'hg --cwd %s locate -I .'], }, 'fallback': 'find %s -type f' }

" enable cscope support
set nocscopetag
set csto=1
set cscopeverbose
set cscopequickfix=s-,c-,d-,i-,t-,e-
nnoremap <C-\>s :cs find s <C-R>=expand("<cword>")<CR><CR>
nnoremap <C-\>g :cs find g <C-R>=expand("<cword>")<CR><CR>
nnoremap <C-\>c :cs find c <C-R>=expand("<cword>")<CR><CR>
nnoremap <C-\>t :cs find t <C-R>=expand("<cword>")<CR><CR>
nnoremap <C-\>e :cs find e <C-R>=expand("<cword>")<CR><CR>
nnoremap <C-\>f :cs find f <C-R>=expand("<cfile>")<CR><CR>
nnoremap <C-\>i :cs find i ^<C-R>=expand("<cfile>")<CR>$<CR>
nnoremap <C-\>d :cs find d <C-R>=expand("<cword>")<CR><CR>
function! LoadCscope()
  let db = findfile("cscope.out", ".;")
  if (!empty(db))
    let path = strpart(db, 0, match(db, "/cscope.out$"))
    set nocscopeverbose " suppress 'duplicate connection' error
    exe "cs reset"
    exe "cs add " . db . " " . path
    set cscopeverbose
  endif
endfunction
au BufEnter /* call LoadCscope()


" configure multi-key timeouts
set timeoutlen=4000
set ttimeout
set ttimeoutlen=100

" find and replace all occurances of the word under the cursor
nnoremap gs :%s/\<<C-r><C-w>\>//g<Left><Left>

" sort the selection
xnoremap s :'<,'>sort<CR>

" ctrp plugin
let g:ctrlp_map = '<C-f>'

" grep shortcuts
command! -nargs=+ Gr execute 'silent Ggrep!' <q-args> | silent! botright cwindow 15 | cc | redraw! | let @/=<q-args> | set hls
nnoremap gr :Gr <C-R>=expand("<cword>")<CR><CR>

function! MyTabLine()
  let s = ''
  let t = tabpagenr()

  for i in range(1, tabpagenr('$'))
    let s .= '%' . i . 'T'

    " get buffer name
    let buflist = tabpagebuflist(i)
    let winnr  = tabpagewinnr(i)
    let bufnm  = buflist[winnr - 1]
    let file   = bufname(bufnm)
    let buftype = getbufvar(bufnm, 'buftype')

    if buftype ==# 'nofile'
      if file =~ '\/.'
        let file = substitute(file, '.*\/\ze.', '', '')
      endif
    else
      let file = fnamemodify(file, ':t')
    endif
    if empty(file)
      let file = '[No Name]'
    endif

    let mod = getbufvar(bufnm, '&modified') ? ' •' : ''

    " highlight + edges
    if i == t

      let s .= '%#TabCap#%#TabLineSel#' . i . ' ' . file . mod . '%#TabCap#%#TabLine# '
    else
      if getbufvar(bufnm, '&modified')

        let s .= '%#TabCapMod#%#TabLineMod#' . i . ' ' . file . mod . '%#TabCapMod#%#TabLine# '
      else
        let s .= '%#TabLine# ' . i . ' ' . file . mod . '  '
      endif
    endif
  endfor

  " fill + close button
  let s .= '%#TabLineFill#%T%='
  let s .= (tabpagenr('$') > 1 ? '%999X✕' : '✕')
  return s
endfunction


let g:clang_format#style_options = { "BinPackArguments" : "false", "BinPackParameters" : "false", "CommentPragmas" : ".*\\$", "Language" : "Cpp", "Standard" : "C++11"}
au BufWrite *.{cc,cpp,h} :ClangFormat

" Toggle checkboxes
fu! ToggleCB()
	let line = getline('.')

	if(match(line, "\\[ \\]") != -1)
		let line = substitute(line, "\\[ \\]", "[x]", "")
	elseif(match(line, "\\[x\\]") != -1)
		let line = substitute(line, "\\[x\\]", "[ ]", "")
	endif

	call setline('.', line)
endf

command! ToggleCB call checkbox#ToggleCB()

nnoremap <silent> gk :ToggleCB<cr>

" CSV files
hi CSVColumnEven term=bold ctermbg=Black ctermfg=White
hi CSVColumnOdd  term=bold ctermbg=Grey ctermfg=Black
" let g:csv_autocmd_arrange	   = 1
" let g:csv_autocmd_arrange_size = 1024*1024
let g:csv_highlight_column = 'y'

" Python document generation
" To install: ~/.vim/bundle/vim-pydocstring/lib/install.sh ~/.vim/bundle/vim-pydocstring/lib/install.sh
let g:pydocstring_formatter = 'google'
let g:pydocstring_enable_mapping = '0'
nnoremap <F10> :Pydocstring<CR>

" Git shortcuts
" :Gdiff should show side-by-side
set diffopt=vertical
:command! Diff Gdiff master
function! ToggleGdiffsplit()
  if exists('t:gdiffsplit_winid') && win_gotoid(t:gdiffsplit_winid) && &diff
    windo if &diff | diffoff | endif
    if win_gotoid(t:gdiffsplit_winid)
      close
    endif
    unlet t:gdiffsplit_winid
  else
    let l:cur = win_getid()
    Gdiffsplit HEAD
    let t:gdiffsplit_winid = win_getid()
    call win_gotoid(l:cur)
  endif
endfunction
nnoremap <leader>d <Cmd>call ToggleGdiffsplit()<CR>

" :Rc should open vimrc
:command! Rc :edit! ~/.vimrc
:command! Src :source ~/.vimrc

" Copy to clipboard
nmap <leader>c <Plug>OSCYankOperator
nmap <leader>cc <leader>c_
vmap <leader>c <Plug>OSCYankVisual

" Packages
call plug#begin('~/.vim/plugged')

Plug 'tpope/vim-fugitive'
Plug 'majutsushi/tagbar'
Plug 'Valloric/ListToggle'
Plug 'chrisbra/csv.vim'
Plug 'ctrlpvim/ctrlp.vim'
Plug 'powerman/vim-plugin-AnsiEsc'
Plug 'rhysd/conflict-marker.vim'
Plug 'sheerun/vim-polyglot'
Plug 'ojroques/vim-oscyank'
Plug 'madox2/vim-ai'
Plug 'neoclide/coc.nvim', {'branch': 'release'}

call plug#end()

" Coc extensions for: python, rust, go, java, c/c++, ts/js, html, css, json, yaml, sh, snippets
let g:coc_global_extensions = [
      \ 'coc-pyright',
      \ 'coc-rust-analyzer',
      \ 'coc-go',
      \ 'coc-java',
      \ 'coc-clangd',
      \ 'coc-tsserver',
      \ 'coc-html',
      \ 'coc-css',
      \ 'coc-yaml',
      \ 'coc-sh',
      \ 'coc-snippets',
      \ 'coc-css',
      \ 'coc-prettier'
      \ ]
let g:coc_user_config = {
\ 'pyright.enable': v:true,
\ 'pyright.disableOrganizeImports': v:false,
\ 'coc.preferences.codeActionOnSave': ['source.organizeImports'],
\ 'css.lint.unknownProperties': 'ignore',
\}
" \ 'diagnostic.virtualTextCurrentLineOnly': v:false, 
" \ 'diagnostic.virtualText': v:true,
" \ 'diagnostic.virtualTextPrefix': ' ❯❯❯ ',

" Filetype settings
filetype plugin indent on
syntax on

" custom colors
colorscheme default
highlight Comment                      ctermfg=7
highlight TabLine      cterm=underline ctermfg=7  ctermbg=NONE
highlight TabLineSel   cterm=NONE      ctermfg=0  ctermbg=2
highlight TabLineFill  cterm=underline ctermfg=7  ctermbg=NONE
highlight TabCap       cterm=NONE      ctermfg=2  ctermbg=NONE
highlight TabLineMod   cterm=NONE      ctermfg=0 ctermbg=7
highlight TabCapMod    cterm=NONE      ctermfg=7  ctermbg=NONE
highlight StatusLine   cterm=underline,bold ctermfg=2  ctermbg=None
highlight StatusCap    cterm=underline ctermfg=2  ctermbg=0
highlight StatusLineNC cterm=underline ctermfg=7  ctermbg=NONE
highlight VertSplit    cterm=NONE      ctermfg=7  ctermbg=NONE
highlight Search       cterm=NONE      ctermfg=0  ctermbg=3
highlight IncSearch    cterm=NONE      ctermfg=0  ctermbg=3
highlight DiffAdd      cterm=underline,italic ctermfg=2   ctermbg=NONE
highlight DiffChange   cterm=NONE      ctermfg=NONE ctermbg=NONE
highlight DiffDelete   cterm=reverse   ctermfg=9   ctermbg=NONE
highlight DiffText     cterm=underline,italic ctermfg=4   ctermbg=NONE
" Inline type hints (inlay hints)
highlight CocInlayHint cterm=italic    ctermfg=7  ctermbg=NONE
" Dropdown (completion menu)
highlight NormalFloat        cterm=NONE ctermbg=NONE ctermfg=NONE
highlight SignColumn ctermbg=NONE ctermfg=NONE
" Error formatting
highlight CocErrorHighlight cterm=underline
highlight CocWarningHighlight cterm=underline
highlight CocInfoHighlight cterm=underline
highlight CocHintHighlight cterm=underline
highlight CocErrorVirtualText    cterm=italic
highlight CocWarningVirtualText  cterm=italic
highlight CocInfoVirtualText     cterm=italic
highlight CocHintVirtualText     cterm=italic
function! OverrideCocFloats() abort
  hi! NormalFloat        cterm=NONE ctermbg=8 ctermfg=NONE
  hi! CocFloating        cterm=NONE ctermbg=8 ctermfg=NONE
  hi! CocMenuSel         cterm=NONE ctermbg=8    ctermfg=NONE
  hi! FgCocErrorFloatBgCocFloating      cterm=NONE ctermbg=8 ctermfg=9
  hi! FgCocWarningFloatBgCocFloating    cterm=NONE ctermbg=8 ctermfg=11
  hi! FgCocInfoFloatBgCocFloating       cterm=NONE ctermbg=8 ctermfg=12
  hi! FgCocHintFloatBgCocFloating       cterm=NONE ctermbg=8 ctermfg=15
endfunction
augroup CocFloatOverride
  autocmd!
  autocmd VimEnter * call OverrideCocFloats()
  autocmd ColorScheme * call OverrideCocFloats()
  autocmd User CocNvimInit call OverrideCocFloats()
augroup END

set fillchars=vert:│

" TAB accepts the currently selected completion item
inoremap <silent><expr> <Tab>
      \ coc#pum#visible() ? coc#pum#confirm() :
      \ "\<Tab>"

" fancy tab bar
set stal=2
set tabline=%!MyTabLine()
set showtabline=1

" fancy status line
function! StatusLineFunc()
  if win_getid() == g:statusline_winid
    return '%<%F %h%m%r%y %= %-14.(%l,%c%V %) %P'
  else
    return '%<%F %h%m%r%y %= %-14.(%l,%c%V %) %P'
  endif
endfunction
set fillchars+=stl:┈,stlnc:\ 
set statusline=%!StatusLineFunc()

" Vim-AI Configuration
" <leader>w (visual): Copy selection, append diagnostics messages, start AI chat.
" <leader>w (normal): Append current line diagnostic message, start AI chat.
" <leader>e (visual/normal): Edit with AI with optional prompt.
" <leader>m (normal): Pick AI model and update vim_ai_edit.options.model.
let g:vim_ai_token_file_path = '~/.config/openrouter.token'
let vim_ai_endpoint_url = 'https://openrouter.ai/api/v1/chat/completions'

" Top 10 coding models on OpenRouter (prices per 1M tokens)
" openai/gpt-5-codex            → in: $1.25   out: $10.00
" anthropic/claude-4.5-sonnet   → in: $3.00   out: $15.00
" x-ai/grok-code-fast-1         → in: $0.20   out: $1.50
" google/gemini-2.5-pro         → in: $1.25   out: $10.00
" z-ai/glm-4.6                  → in: $0.40   out: $1.75
" anthropic/claude-4.5-haiku    → in: $1.00   out: $5.00
" openai/gpt-5-mini             → in: $0.24   out: $2.00
" qwen/qwen3-coder              → in: $0.22   out: $0.95
let g:vim_ai_models = [
      \ 'openai/gpt-5-codex',
      \ 'anthropic/claude-4.5-sonnet',
      \ 'x-ai/grok-code-fast-1',
      \ 'z-ai/glm-4.6',
      \ 'google/gemini-2.5-pro',
      \ 'anthropic/claude-4.5-haiku',
      \ 'openai/gpt-5-mini',
      \ 'qwen/qwen3-coder'
      \ ]
let g:vim_ai_model = g:vim_ai_models[0]

command! VimAISelectModel call s:vim_ai_select_model()
function! s:vim_ai_select_model() abort
  let l:highlight_current = "\x1b[1;33m"
  let l:highlight_regular = "\x1b[1;36m"
  let l:highlight_title = "\x1b[1;34m"
  let l:highlight_reset = "\x1b[0m"
  let l:models = copy(g:vim_ai_models)
  let l:choice = inputlist([l:highlight_title . '------------- Select model [' .  g:vim_ai_model . '] --------------' . l:highlight_reset] + map(l:models, {i, v -> (v == g:vim_ai_model ? l:highlight_current : l:highlight_regular) . printf('%d. %s%s', i + 1, v, v == g:vim_ai_model ? ' (current)' : '') . l:highlight_reset}))
  if l:choice >= 1 && l:choice <= len(g:vim_ai_models)
    let g:vim_ai_model = g:vim_ai_models[l:choice - 1]
    let g:vim_ai_edit.options.model = g:vim_ai_model
    let g:vim_ai_chat.options.model = g:vim_ai_model
  endif
endfunction

nnoremap <Leader>m :VimAISelectModel<CR>

let g:vim_ai_edit = {
\  "provider": "openai",
\  "prompt": "",
\  "options": {
\    "model": vim_ai_models[0],
\    "endpoint_url": vim_ai_endpoint_url,
\    "max_tokens": 0,
\    "max_completion_tokens": 0,
\    "temperature": 0.1,
\    "request_timeout": 20,
\    "stream": 1,
\    "auth_type": "bearer",
\    "token_file_path": g:vim_ai_token_file_path,
\    "token_load_fn": "",
\    "selection_boundary": "",
\    "initial_prompt": "",
\    "frequency_penalty": "",
\    "logit_bias": "",
\    "logprobs": "",
\    "presence_penalty": "",
\    "reasoning_effort": "",
\    "seed": "",
\    "stop": "",
\    "top_logprobs": "",
\    "top_p": "",
\    "reasoning": "",
\  },
\  "ui": {
\    "paste_mode": 1,
\  },
\}
let g:vim_ai_edit.options.initial_prompt =<< trim END
>>> system

You are coding assistant.
Answer only with a snippet of code.
When asked to complete a task, fully implement the code to do it.
Do not wrap code in markdown code block or any other characters.
Include all input code that shuold not be removed.
Do not add any code beyond what is needed for the task.
END

let g:vim_ai_chat = {
\  "provider": "openai",
\  "prompt": "",
\  "options": {
\    "model": g:vim_ai_model,
\    "endpoint_url": vim_ai_endpoint_url,
\    "max_tokens": 0,
\    "max_completion_tokens": 0,
\    "temperature": 1,
\    "request_timeout": 20,
\    "stream": 1,
\    "auth_type": "bearer",
\    "token_file_path": g:vim_ai_token_file_path,
\    "token_load_fn": "",
\    "selection_boundary": "",
\    "initial_prompt": "",
\    "frequency_penalty": "",
\    "logit_bias": "",
\    "logprobs": "",
\    "presence_penalty": "",
\    "reasoning_effort": "",
\    "seed": "",
\    "stop": "",
\    "top_logprobs": "",
\    "top_p": "",
\    "reasoning": "",
\  },
\  "ui": {
\    "open_chat_command": "preset_right",
\    "scratch_buffer_keep_open": 0,
\    "populate_options": 0,
\    "populate_all_options": 0,
\    "force_new_chat": 0,
\    "paste_mode": 1,
\  },
\}
let g:vim_ai_chat.options.initial_prompt =<< trim END
>>> system

You are coding assistant.
Answer shortly, concisely, and only what you are asked.
Do not provide any explanation or comments.
Answer as concisely as possible.
END

function! AIEditRangeWithPrompt() range
  let prompt = input('AIEdit prompt (optional): ')
  if empty(prompt)
    return
  endif
  execute "'<,'>AIEdit " . shellescape(prompt)
endfunction

xnoremap <silent> <leader>e :<C-u>call AIEditRangeWithPrompt()<CR>
nnoremap <silent> <leader>e :<C-u>call AIEditRangeWithPrompt()<CR>

" --- DIAGNOSTICS (ALE → Coc) used by AI and detail toggling ---

" Find the first diagnostic item in a range (by lnum then col)
function! s:FirstALEItemInRange(start_lnum, end_lnum)
  if !exists('*CocAction') | return {} | endif
  let items = CocAction('diagnosticList')
  let first = {}
  let curfile = expand('%:p')
  for it in items
    if get(it, 'file', '') !=# curfile
      continue
    endif
    if it.lnum >= a:start_lnum && it.lnum <= a:end_lnum
      if empty(first)
            \ || it.lnum < first.lnum
            \ || (it.lnum == first.lnum && get(it,'col',0) < get(first,'col',0))
        let first = it
      endif
    endif
  endfor
  return first
endfunction

" Build human-readable diagnostic lines for a given (lnum, col)
function! s:GetALEPreviewLinesAt(lnum, col)
  if !exists('*CocAction') | return [] | endif
  let items = CocAction('diagnosticList')
  let curfile = expand('%:p')
  let lines = []
  for it in items
    if get(it, 'file', '') !=# curfile
      continue
    endif
    if it.lnum == a:lnum
      let sevval = get(it, 'severity', 0)
      if type(sevval) == type(0)
        let sevmap = {1: 'Error', 2: 'Warning', 3: 'Information', 4: 'Hint'}
        let sevname = get(sevmap, sevval, 'Information')
      else
        let sevname = sevval
      endif
      let prefix = sevname[0]
      let msg = get(it, 'message', '')
      let src = get(it, 'source', 'coc')
      let code = get(it, 'code', '')
      let text = printf('%s: %s [%s%s%s]', prefix, msg, src, code ==# '' ? '' : ' ', code)
      call add(lines, text)
    endif
  endfor
  return lines
endfunction

" Toggle detail window using Coc diagnostics (replaces ToggleALEDetail)
function! ToggleALEDetail() abort
  if exists('*CocAction')
    if CocAction('hasProvider', 'hover')
      call CocActionAsync('doHover')
    else
      echo "No diagnostics and no hover provider"
    endif
  else
    echo "No diagnostics"
  endif
endfunction


" map ' to toggle diagnostic detail (same key as before)
nnoremap <silent> ' :call ToggleALEDetail()<CR>

" --- ensure we're in (or open) the aichat buffer and resize ---
function! s:FocusAIChatHalfWidth()
  AIChat
  let bn = bufnr('aichat')
  if bn != -1
    let wnr = bufwinnr(bn)
    if wnr > -1 | execute wnr . 'wincmd w' | endif
  endif
  execute 'vertical resize' float2nr(&columns / 2)
endfunction

" --- VISUAL: send selection + diagnostic lines (Coc-based) ---
function! AIChatAppendVisualAndALE() range
  " If already in aichat, just show the UI and bail
  if expand('%:t') ==# 'aichat'
    AIChat
    return
  endif

  " Yank selection for pasting into chat
  normal! gv"ay

  " Compute visual range robustly
  let s = getpos("'<")[1]
  let e = getpos("'>")[1]
  let start = min([s, e])
  let finish = max([s, e])

  " Find first diagnostic item in that range
  let item = s:FirstALEItemInRange(start, finish)

  " If we found one, capture preview content; else []
  let preview_lines = []
  if !empty(item)
    let preview_lines = s:GetALEPreviewLinesAt(item.lnum, get(item,'col',1))
  endif

  " Open/focus chat and paste
  call s:FocusAIChatHalfWidth()
  normal! G
  if @a !=# ''
    execute 'normal! "ap'
  endif
  if !empty(preview_lines)
    call append(line('$'), '')
    call append(line('$'), preview_lines)
  endif
  normal! G
endfunction

" --- NORMAL: open chat; append current line's diagnostic preview if present ---
function! AIChatOpenWithALE()
  " Do nothing if already in aichat
  if expand('%:t') ==# 'aichat'
    return
  endif

  " Find diagnostic item on the current line
  let item = s:FirstALEItemInRange(line('.'), line('.'))
  let preview_lines = []
  let context_lines = []
  let error_line = ''

  if !empty(item)
    " Diagnostic preview text
    let preview_lines = s:GetALEPreviewLinesAt(item.lnum, get(item, 'col', 1))

    " Exact line containing the error
    let error_line = getline(item.lnum)

    " +/- 10 lines context
    let start_lnum = max([1, item.lnum - 10])
    let end_lnum   = min([line('$'), item.lnum + 10])
    let context_lines = getline(start_lnum, end_lnum)
  endif

  " Open/focus chat window
  call s:FocusAIChatHalfWidth()

  " Append information to chat
  if !empty(preview_lines) || !empty(context_lines)
    normal! G
    let last = line('$')

    " --- main diagnostic prompt ---
    call append(last, '')
    let last += 1
    call append(last, '--- Explain reason for this error and provide code fix for the line with the error and surrounding errors in markdown code block with language ---')
    let last += 1

    " diagnostic text
    if !empty(preview_lines)
      call append(last, preview_lines)
      let last += len(preview_lines)
    endif

    " --- error line ---
    if !empty(error_line)
      call append(last, '')
      let last += 1
      call append(last, '--- Here is the line with the error ---')
      let last += 1
      call append(last, error_line)
      let last += 1
    endif

    " --- context block ---
    if !empty(context_lines)
      call append(last, '')
      let last += 1
      call append(last, '--- code context (+/- 10 lines) ---')
      let last += 1
      call append(last, context_lines)
      let last += len(context_lines)
    endif

    " go to bottom & start a new prompt line
    normal! G
    normal! o
  endif
endfunction


" --- mappings ---
" Visual: selection + exact diagnostic preview
xnoremap <silent> <leader>w :<C-u>call AIChatAppendVisualAndALE()<CR>
" Normal: open chat + exact current-line diagnostic preview
nnoremap <silent> <leader>w :<C-u>call AIChatOpenWithALE()<CR>

" Scratch buffer operations  
" visual <leader>a appends selection to scratch buffer
" normal <leader>a clears all scratch contents
" <leader>p pastes scratch lines at cursor position
" <leader>t toggles the vertical scratch buffer split
" --- append selection to right-side 'scratch' ---
function! AppendScratchFromVisual()
  let win = win_getid()
  normal! gv"ay

  let name = 'scratch'
  if bufexists(name)
    let bn = bufnr(name)
    let w  = bufwinnr(bn)
    if w > -1
      execute w . 'wincmd w'
    else
      execute 'vert sbuffer ' . bn
    endif
  else
    vert new | setlocal buftype=nofile bufhidden=hide noswapfile
    execute 'file ' . name
  endif

  normal! G
  if getline('$') !=# ''
    call append(line('$'), '')
  endif
  execute 'normal! "ap'
  call win_gotoid(win)
endfunction

" --- clear 'scratch' without opening a split ---
function! ClearScratchBuffer()
  let name = 'scratch'
  let bn = bufnr(name)
  if bn == -1 | return | endif

  let w = bufwinnr(bn)
  if w > -1
    let win = win_getid()
    execute w . 'wincmd w'
    %delete _
    call win_gotoid(win)
  else
    try
      call deletebufline(bn, 1, '$')
    catch
      call setbufline(bn, 1, '')
      call deletebufline(bn, 2, '$')
    endtry
  endif
endfunction

function! PasteScratchBuffer()
  let name = 'scratch'
  if !bufexists(name)
    echo "scratch not found."
    return
  endif
  let lines = getbufline(name, 1, '$')
  call append('.', lines)
endfunction

function! ToggleScratchBuffer() abort
  let name = 'scratch'
  let bn = bufnr(name)
  if bn > 0
    let w = bufwinnr(bn)
    if w > -1
      execute w . 'wincmd c'
      return
    endif
  endif
  if bn == -1
    vert new | setlocal buftype=nofile bufhidden=hide noswapfile
    execute 'file ' . name
  else
    execute 'vert sbuffer ' . bn
  endif
endfunction

" --- mappings ---
xnoremap <silent> <leader>a :<C-u>call AppendScratchFromVisual()<CR>
nnoremap <silent> <leader>a :<C-u>call ClearScratchBuffer()<CR>
nnoremap <silent> <leader>p :<C-u>call PasteScratchBuffer()<CR>
nnoremap <silent> <leader>t :<C-u>call ToggleScratchBuffer()<CR>

" --- Python formatter chain to mimic ALE fixers (autoflake + isort + autopep8/yapf + whitespace) ---

function! s:FormatPythonBuffer()
  " Run autoflake
  if executable('autoflake')
    silent execute '%!autoflake --ignore-init-module-imports --remove-all-unused-imports --ignore-pass-after-docstring -'
  endif

  " Run isort
  if executable('isort')
    silent execute '%!isort -'
  endif

  " Run autopep8 with your old options
  if executable('autopep8')
    silent execute '%!autopep8 --ignore F811,W503,W504,E731,E125 -'
  endif

  " Optionally run yapf if installed (last in chain, like another style pass)
  if executable('yapf')
    silent execute '%!yapf'
  endif

  " Trim trailing whitespace (ALE trim_whitespace)
  silent keepjumps %s/\s\+$//e

  " Remove trailing blank lines at EOF (ALE remove_trailing_lines)
  silent keepjumps %s/\n\+\%$//e
endfunction

" --- Format on save for key languages (Python/Rust/TS/JS/HTML/etc) ---

augroup FormatOnSave
  autocmd!
  " Python: use our explicit chain to mirror ALE fixers
  autocmd BufWritePre *.py call s:FormatPythonBuffer()

  " Rust: use Coc LSP formatting (rust-analyzer → rustfmt)
  autocmd BufWritePre *.rs silent! call CocAction('format')

  " TypeScript/JavaScript/JSON: LSP formatting (tsserver, json)
  autocmd BufWritePre *.ts,*.tsx,*.js,*.jsx,*.json silent! call CocAction('format')

  " HTML/CSS/YAML/SH: LSP formatting where supported
  autocmd BufWritePre *.html,*.htm,*.css,*.scss,*.yaml,*.yml,*.sh silent! call CocAction('format')
augroup END
