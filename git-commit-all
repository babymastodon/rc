#!/usr/bin/env bash
# git-commit-all: commit all tracked changes with a concise, emoji message.
# Decision is based on the TOP 3 files by churn (adds+dels).
# Usage: git-commit-all [optional note]

set -euo pipefail
note="${*:-}"

# --- helpers ---
in_repo() { git rev-parse --show-toplevel >/dev/null 2>&1; }
is_ws_only() { git diff -w --quiet; }   # working tree vs index, ignores whitespace
join_commas() { awk 'BEGIN{ORS=""}{if(NR>1)printf(", ");printf("%s",$0)}END{printf("\n")}'; }

in_repo || { echo "Not a git repo" >&2; exit 1; }
# Nothing to commit with -a?
if git diff --quiet; then
  echo "Nothing to commit. (Untracked files require 'git add')" >&2
  exit 0
fi

# Diffs (worktree ↔ index); -M -C to detect renames/copies
NAME_STATUS=$(git diff --name-status -M -C)
NUMSTAT=$(git diff --numstat -M -C)
PATCH=$(git diff)

# Totals
TOTAL_ADDS=$(echo "$NUMSTAT" | awk '{a=$1;a=(a=="-")?0:a;s+=a}END{print s+0}')
TOTAL_DELS=$(echo "$NUMSTAT" | awk '{d=$2;d=(d=="-")?0:d;s+=d}END{print s+0}')
TOTAL_CHURN=$(( TOTAL_ADDS + TOTAL_DELS ))
DATE=$(date +"%Y-%m-%d %H:%M")

# Build per-file stats and pick TOP 3 by churn
# Fields: churn \t adds \t dels \t path
TOP3_LINES=$(echo "$NUMSTAT" \
  | awk '{a=$1; if(a=="-") a=0; d=$2; if(d=="-") d=0; $1=$2=""; sub(/^[ \t]+/,""); print a+d "\t" a "\t" d "\t" $0 }' \
  | sort -nr | head -3)

# Extract lists for message
TOP3_FILES=$(echo "$TOP3_LINES" | cut -f4- | join_commas)
# Fallback if somehow empty
if [[ -z "$TOP3_FILES" ]]; then
  readarray -t ALLFILES < <(echo "$NUMSTAT" | awk 'NF>=3{print $3}')
  TOP3_FILES=$(printf "%s\n" "${ALLFILES[@]}" | head -3 | join_commas)
fi

# Count total files for optional suffix
TOTAL_FILES=$(echo "$NUMSTAT" | awk 'NF>=3{n++}END{print n+0}')

# Map file -> status for top3 (A/M/D/R/C)
# For renames, NAME_STATUS has 3 columns: Rxx \t old \t new ; treat "new" path as the file
declare -A STATUS_MAP
while IFS=$'\t' read -r s p1 p2; do
  [[ -z "${s:-}" ]] && continue
  if [[ "$s" =~ ^R ]]; then
    STATUS_MAP["$p2"]="R"
  elif [[ "$s" =~ ^C ]]; then
    STATUS_MAP["$p2"]="C"
  else
    STATUS_MAP["$p1"]="${s:0:1}"
  fi
done < <(printf "%s\n" "$NAME_STATUS")

# Tally statuses and local churn inside TOP 3
T3_ADDS=0; T3_DELS=0; CNT_A=0; CNT_D=0; CNT_R=0; CNT_M=0
while IFS=$'\t' read -r churn adds dels path; do
  [[ -z "${path:-}" ]] && continue
  T3_ADDS=$((T3_ADDS + adds))
  T3_DELS=$((T3_DELS + dels))
  st="${STATUS_MAP[$path]:-M}"   # assume M if unknown
  case "$st" in
    A) CNT_A=$((CNT_A+1));;
    D) CNT_D=$((CNT_D+1));;
    R) CNT_R=$((CNT_R+1));;
    *) CNT_M=$((CNT_M+1));;
  esac
done < <(printf "%s\n" "$TOP3_LINES")

# Ratios (stabilized)
RATIO_ALL=$(awk -v a="$TOTAL_ADDS" -v d="$TOTAL_DELS" 'BEGIN{printf "%.2f",(a+1)/(d+1)}')
RATIO_T3=$(awk -v a="$T3_ADDS" -v d="$T3_DELS" 'BEGIN{printf "%.2f",(a+1)/(d+1)}')

# Content cues (allowed)
PERF_HINT=false
echo "$PATCH" | grep -E -i -q '(^|\b)(perf|optimi[sz]|hot path|O\()' && PERF_HINT=true
WS_ONLY=false; is_ws_only && WS_ONLY=true

# --- Decide category (STRICTLY from TOP 3, with small global guards) ---
# Order: whitespace → rename → add/remove → tiny → bugfix → ratio (feat/prune/refactor) → perf → edit
type="edit"; emoji="📝"

if $WS_ONLY; then
  type="cleanup"; emoji="🧹"
elif (( CNT_R >= 2 )) || { (( CNT_R >= 1 )) && (( CNT_A + CNT_D == 0 )); }; then
  type="rename"; emoji="🔁"
elif (( CNT_D >= 2 )); then
  type="remove"; emoji="🔥"
elif (( CNT_A >= 2 )); then
  type="add"; emoji="➕"
elif (( T3_ADDS + T3_DELS <= 3 )); then
  type="oneliner"; emoji="⚡"
elif (( $(echo "$T3_ADDS+$T3_DELS" | bc 2>/dev/null || echo $((T3_ADDS+T3_DELS))) <= 20 )) && (( CNT_M + CNT_A + CNT_D <= 3 )); then
  type="bugfix"; emoji="🐛"
elif awk -v r="$RATIO_T3" 'BEGIN{exit !(r>=3.0)}'; then
  type="feat"; emoji="✨"
elif awk -v r="$RATIO_T3" 'BEGIN{exit !(r<=0.33)}'; then
  type="prune"; emoji="🔥"
elif awk -v r="$RATIO_T3" 'BEGIN{exit !(r>=0.7 && r<=1.3)}' && (( T3_ADDS + T3_DELS > 300 )); then
  type="refactor"; emoji="♻️"
elif $PERF_HINT; then
  type="perf"; emoji="🚀"
else
  type="edit"; emoji="📝"
fi

# Append optional note compactly
[[ -n "$note" ]] && type="$type — $note"

# Compose message
suffix=" (+${TOTAL_ADDS}/-${TOTAL_DELS}, ${DATE})"
(( TOTAL_FILES > 3 )) && suffix="${suffix} (${TOTAL_FILES} files)"
msg="${emoji} ${type} — ${TOP3_FILES}${suffix}"

# Commit all tracked changes
git commit -a -m "$msg"

