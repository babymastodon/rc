#!/usr/bin/env bash
# git-commit-all: concise auto-commit with emoji + category decided from top-3 files' line-level categories.
# Usage: git-commit-all [optional note]

set -euo pipefail
note="${*:-}"

# --- helpers ---------------------------------------------------------------
in_repo() { git rev-parse --show-toplevel >/dev/null 2>&1; }
is_ws_only() { git diff -w --quiet; } # whitespace-only overall edit?
join_commas(){ awk 'BEGIN{ORS=""}{if(NR>1)printf(", ");printf("%s",$0)}END{print ""}'; }
die(){ echo "git-commit-all: $*" >&2; exit 1; }

in_repo || die "not a git repo"
if git diff --quiet; then
  echo "Nothing to commit. (Untracked files need 'git add')" >&2
  exit 0
fi

# Get working-tree diff (this is what -a will commit)
NAME_STATUS=$(git diff --name-status -M -C)
NUMSTAT=$(git diff --numstat -M -C)
PATCH=$(git diff)  # unified diff including hunks

# Totals & timestamp
TOTAL_ADDS=$(echo "$NUMSTAT" | awk '{a=$1; if(a=="-") a=0; s+=a} END{print s+0}')
TOTAL_DELS=$(echo "$NUMSTAT" | awk '{d=$2; if(d=="-") d=0; s+=d} END{print s+0}')
TOTAL_FILES=$(echo "$NUMSTAT" | awk 'NF>=3{n++} END{print n+0}')
DATE=$(date +"%Y-%m-%d %H:%M")

# Top-3 files by churn
TOP3_LINES=$(echo "$NUMSTAT" \
  | awk '{a=$1; if(a=="-") a=0; d=$2; if(d=="-") d=0; $1=$2=""; sub(/^[ \t]+/,""); print a+d "\t" a "\t" d "\t" $0 }' \
  | sort -nr | head -3)
TOP3_FILES=$(echo "$TOP3_LINES" | cut -f4- | join_commas)
if [[ -z "$TOP3_FILES" ]]; then
  readarray -t ALLFILES < <(echo "$NUMSTAT" | awk 'NF>=3{print $3}')
  TOP3_FILES=$(printf "%s\n" "${ALLFILES[@]}" | head -3 | join_commas)
fi

# Map file -> status (A/M/D/R/C) to recognize adds/removes/renames in top-3
declare -A STATUS_MAP
while IFS=$'\t' read -r s p1 p2; do
  [[ -z "${s:-}" ]] && continue
  if [[ "$s" =~ ^R ]]; then STATUS_MAP["$p2"]="R"
  elif [[ "$s" =~ ^C ]]; then STATUS_MAP["$p2"]="C"
  else STATUS_MAP["$p1"]="${s:0:1}"
  fi
done < <(printf "%s\n" "$NAME_STATUS")

# --- category patterns ------------------------------------------------------
docs_file_pat='(^|/)docs?(/|$)|\.(md|rst|adoc|mdx|txt)$'
tests_file_pat='(^|/)(test|tests|__tests__|spec)(/|$)|\.(test|spec)\.[^/]+$'
config_file_pat='\.(json|ya?ml|toml|ini|conf|config)$|(^|/)\.(editorconfig|eslintrc(\.json)?|prettier(rc|\.config\.js)?|stylelintrc(\.json)?)$|(^|/)Makefile$|(^|/)Dockerfile$|(^|/)docker-compose\.ya?ml$|(^|/)pyproject\.toml$|(^|/)setup\.(cfg|py)$|(^|/)tsconfig\.json$'
deps_file_pat='(^|/)package(-lock)?\.json$|(^|/)yarn\.lock$|(^|/)pnpm-lock\.yaml$|(^|/)poetry\.lock$|(^|/)Pipfile(\.lock)?$|(^|/)Gemfile(\.lock)?$|(^|/)Cargo\.(lock|toml)$|(^|/)go\.(mod|sum)$|(^|/)composer\.(json|lock)$|(^|/)Podfile(\.lock)?$|(^|/)pom\.xml$|(^|/)build\.gradle(\.kts)?$'
version_files_pat='(^|/)CHANGELOG\.md$|(^|/)CHANGES\.md$|(^|/)VERSION$|(^|/)(package\.json|pyproject\.toml|Cargo\.toml)'

# Line-level heuristics (comment/docstring markers)
# python """ or '''; JS/TS /** */ and // ; general # // ; markdown headings
is_docline() {
  local line="$1" path="$2"
  if [[ "$path" =~ $docs_file_pat ]]; then return 0; fi
  [[ "$line" =~ ^[[:space:]]*# ]] && return 0
  [[ "$line" =~ ^[[:space:]]*// ]] && return 0
  [[ "$line" =~ ^[[:space:]]*/\* ]] && return 0
  [[ "$line" =~ ^[[:space:]]*\* ]] && return 0
  [[ "$line" =~ \"\"\"|\'\'\' ]] && return 0
  [[ "$line" =~ ^[[:space:]]*// ]] && return 0
  [[ "$line" =~ ^[[:space:]]*[-\*\+]?[[:space:]]#[[:space:]] ]] && return 0 # md h1-like in lists
  [[ "$line" =~ ^[[:space:]]*# ]] && return 0
  [[ "$line" =~ ^[[:space:]]*#{1,6}[[:space:]] ]] && return 0   # markdown headings
  return 1
}
is_version_line() {
  local line="$1"
  [[ "$line" =~ version[[:space:]]*[:=][[:space:]]*\"?[0-9]+\.[0-9]+(\.[0-9]+)? ]] && return 0
  [[ "$line" =~ ^\+[[:space:]]*\-?[0-9]+\.[0-9]+\.[0-9]+[[:space:]]*$ ]] && return 0 # changelog semver
  return 1
}

# Extract the three paths we’ll analyze deeply
readarray -t T3_PATHS < <(echo "$TOP3_LINES" | cut -f4-)

# --- per-line categorization over TOP-3 files -------------------------------
# We'll parse the unified diff and, for each top-3 file, sum volumes for:
# docs, tests, config, deps, version, code (default)
declare -A vol_add vol_del
for k in docs tests config deps version code; do vol_add[$k]=0; vol_del[$k]=0; done

current=""
while IFS= read -r line; do
  if [[ "$line" =~ ^diff\ --git\ a/(.*)\ b/(.*) ]]; then
    current="${BASH_REMATCH[2]}"
    # only track if in top-3
    match=false
    for p in "${T3_PATHS[@]}"; do [[ "$p" == "$current" ]] && match=true && break; done
    $match || current=""
    continue
  fi
  [[ -z "$current" ]] && continue
  # skip file header markers
  [[ "$line" =~ ^(\+\+\+|\-\-\-) ]] && continue
  # added line
  if [[ "$line" =~ ^\+ ]] ; then
    content="${line:1}"
    # classify by file first
    if [[ "$current" =~ $deps_file_pat ]]; then               ((vol_add[deps]+=1))
    elif [[ "$current" =~ $tests_file_pat ]]; then            ((vol_add[tests]+=1))
    elif [[ "$current" =~ $config_file_pat ]]; then           ((vol_add[config]+=1))
    elif is_docline "$content" "$current"; then               ((vol_add[docs]+=1))
    elif [[ "$current" =~ $version_files_pat ]] && is_version_line "$content"; then ((vol_add[version]+=1))
    else                                                      ((vol_add[code]+=1))
    fi
  # deleted line
  elif [[ "$line" =~ ^\- ]]; then
    content="${line:1}"
    if [[ "$current" =~ $deps_file_pat ]]; then               ((vol_del[deps]+=1))
    elif [[ "$current" =~ $tests_file_pat ]]; then            ((vol_del[tests]+=1))
    elif [[ "$current" =~ $config_file_pat ]]; then           ((vol_del[config]+=1))
    elif is_docline "$content" "$current"; then               ((vol_del[docs]+=1))
    elif [[ "$current" =~ $version_files_pat ]] && is_version_line "$content"; then ((vol_del[version]+=1))
    else                                                      ((vol_del[code]+=1))
    fi
  fi
done <<< "$PATCH"

# Aggregate top-3 stats
t3_add=0; t3_del=0
for k in docs tests config deps version code; do
  ((t3_add += vol_add[$k])); ((t3_del += vol_del[$k]))
done
t3_total=$((t3_add + t3_del))
ratio_t3=$(awk -v a="$t3_add" -v d="$t3_del" 'BEGIN{printf "%.2f",(a+1)/(d+1)}')

# quick top-3 status counts for rename/add/remove emphasis
cnt_A=0; cnt_D=0; cnt_R=0
for p in "${T3_PATHS[@]}"; do
  st="${STATUS_MAP[$p]:-M}"
  case "$st" in A) ((cnt_A++));; D) ((cnt_D++));; R) ((cnt_R++));; esac
done

# whitespace-only?
ws=false; is_ws_only && ws=true

# --- decide category (weight by top-3 category volumes & ratio) -------------
# Category share helpers
share(){ # $1=cat
  local c="$1"; local n=$(( vol_add[$c] + vol_del[$c] ))
  echo "$n"
}

docs_n=$(share docs)
tests_n=$(share tests)
config_n=$(share config)
deps_n=$(share deps)
version_n=$(share version)
code_n=$(share code)

# choose
type="edit"; emoji="📝"

if $ws; then
  type="cleanup"; emoji="🧹"
elif (( cnt_R >= 2 )); then
  type="rename"; emoji="🔁"
elif (( cnt_D >= 2 )) && (( t3_add + t3_del <= 50 )); then
  type="remove"; emoji="🔥"
elif (( cnt_A >= 2 )) && (( t3_add >= 10 )); then
  type="add"; emoji="➕"
elif (( deps_n > 0 )) && (( deps_n >= tests_n + docs_n + config_n + code_n )); then
  type="deps"; emoji="📦"
elif (( config_n > 0 )) && (( config_n >= docs_n )) && (( config_n >= tests_n )) && (( config_n >= deps_n )) && (( config_n >= code_n/2 )); then
  type="config"; emoji="⚙️"
elif (( version_n >= 3 )) && (( deps_n + config_n + docs_n + tests_n <= version_n*2 )); then
  type="version bump"; emoji="🔖"
elif (( tests_n > 0 )) && (( tests_n >= docs_n )) && (( tests_n >= config_n )) && (( tests_n >= deps_n )) && (( tests_n >= code_n/2 )); then
  type="tests"; emoji="✅"
elif (( docs_n > 0 )) && (( docs_n >= tests_n )) && (( docs_n >= config_n )) && (( docs_n >= deps_n )) && (( docs_n >= code_n/2 )); then
  type="docs"; emoji="📚"
# structural / scale-based:
elif (( t3_total <= 3 )); then
  type="oneliner"; emoji="⚡"
elif (( t3_total <= 20 )) && (( ${#T3_PATHS[@]} <= 3 )); then
  type="bugfix"; emoji="🐛"
elif awk -v r="$ratio_t3" 'BEGIN{exit !(r>=3.0)}'; then
  type="feat"; emoji="✨"
elif awk -v r="$ratio_t3" 'BEGIN{exit !(r<=0.33)}'; then
  type="prune"; emoji="🔥"
elif awk -v r="$ratio_t3" 'BEGIN{exit !(r>=0.7 && r<=1.3)}' && (( t3_total > 1200 )); then
  type="rewrite"; emoji="🧨"
elif awk -v r="$ratio_t3" 'BEGIN{exit !(r>=0.7 && r<=1.3)}' && (( t3_total > 300 )); then
  type="refactor"; emoji="♻️"
fi

# optional note
[[ -n "$note" ]] && type="$type — $note"

# message + commit
suffix=" (+${TOTAL_ADDS}/-${TOTAL_DELS}, ${DATE})"
(( TOTAL_FILES > 3 )) && suffix="${suffix} (${TOTAL_FILES} files)"
msg="${emoji} ${type} — ${TOP3_FILES}${suffix}"

git commit -a -m "$msg"

