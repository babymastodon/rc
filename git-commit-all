#!/usr/bin/env bash
# git-commit-all: concise auto-commit; auto-adds modified/deleted files.
# One-line message: <emoji> <type> â€” <top3> (+adds/-dels, YYYY-MM-DD HH:MM) [(N files)]
# Category = weighted by TOP-3 files' line categories (docs/tests/config/deps/version/code)
# Includes: rewrite, docs, version bump, tests, config, deps, cleanup, plus add/remove/rename, refactor, feat, prune, bugfix, oneliner, edit

set -euo pipefail

note="${*:-}"

# ---- helpers (safe under set -e) ------------------------------------------
die(){ echo "git-commit-all: $*" >&2; exit 1; }

in_repo() {
  set +e; git rev-parse --show-toplevel >/dev/null 2>&1; local rc=$?; set -e; return $rc
}

is_ws_only_cached() {
  # true if staged diff is whitespace-only
  set +e; git diff --cached -w --quiet; local rc=$?; set -e; return $rc
}

join_commas(){ awk 'BEGIN{ORS=""}{if(NR>1)printf(", ");printf("%s",$0)}END{print ""}'; }

# ---- preconditions ---------------------------------------------------------
in_repo || die "not a git repo"

# Auto-add modified/deleted tracked files so unstaged mods are included
git add -u

# If nothing staged after auto-add, bail with a message
set +e
git diff --cached --quiet
has_staged=$?
set -e
if [[ $has_staged -eq 0 ]]; then
  echo "Nothing to commit. (Untracked files need 'git add')" >&2
  exit 0
fi

# ---- gather staged diff ----------------------------------------------------
NAME_STATUS=$(git diff --cached --name-status -M -C)
NUMSTAT=$(git diff --cached --numstat -M -C)
PATCH=$(git diff --cached)

# Totals & timestamp
TOTAL_ADDS=$(echo "$NUMSTAT" | awk '{a=$1; if(a=="-") a=0; s+=a} END{print s+0}')
TOTAL_DELS=$(echo "$NUMSTAT" | awk '{d=$2; if(d=="-") d=0; s+=d} END{print s+0}')
TOTAL_FILES=$(echo "$NUMSTAT" | awk 'NF>=3{n++} END{print n+0}')
DATE=$(date +"%Y-%m-%d %H:%M")

# Top-3 files by churn
TOP3_LINES=$(echo "$NUMSTAT" \
  | awk '{a=$1; if(a=="-") a=0; d=$2; if(d=="-") d=0; $1=$2=""; sub(/^[ \t]+/,""); print a+d "\t" a "\t" d "\t" $0 }' \
  | sort -nr | head -3)

TOP3_FILES=$(echo "$TOP3_LINES" | cut -f4- | join_commas)
if [[ -z "$TOP3_FILES" ]]; then
  readarray -t ALLFILES < <(echo "$NUMSTAT" | awk 'NF>=3{print $3}')
  TOP3_FILES=$(printf "%s\n" "${ALLFILES[@]}" | head -3 | join_commas)
fi

# Map file -> status (A/M/D/R/C) for top-3 (to detect add/remove/rename)
declare -A STATUS_MAP
while IFS=$'\t' read -r s p1 p2; do
  [[ -z "${s:-}" ]] && continue
  if [[ "$s" =~ ^R ]]; then STATUS_MAP["$p2"]="R"
  elif [[ "$s" =~ ^C ]]; then STATUS_MAP["$p2"]="C"
  else STATUS_MAP["$p1"]="${s:0:1}"
  fi
done < <(printf "%s\n" "$NAME_STATUS")

# ---- category patterns -----------------------------------------------------
docs_file_pat='(^|/)docs?(/|$)|\.(md|rst|adoc|mdx|txt)$'
tests_file_pat='(^|/)(test|tests|__tests__|spec)(/|$)|\.(test|spec)\.[^/]+$'
config_file_pat='\.(json|ya?ml|toml|ini|conf|config)$|(^|/)\.(editorconfig|eslintrc(\.json)?|prettier(rc|\.config\.js)?|stylelintrc(\.json)?)$|(^|/)Makefile$|(^|/)Dockerfile$|(^|/)docker-compose\.ya?ml$|(^|/)pyproject\.toml$|(^|/)setup\.(cfg|py)$|(^|/)tsconfig\.json$'
deps_file_pat='(^|/)package(-lock)?\.json$|(^|/)yarn\.lock$|(^|/)pnpm-lock\.yaml$|(^|/)poetry\.lock$|(^|/)Pipfile(\.lock)?$|(^|/)Gemfile(\.lock)?$|(^|/)Cargo\.(lock|toml)$|(^|/)go\.(mod|sum)$|(^|/)composer\.(json|lock)$|(^|/)Podfile(\.lock)?$|(^|/)pom\.xml$|(^|/)build\.gradle(\.kts)?$'
version_files_pat='(^|/)CHANGELOG\.md$|(^|/)CHANGES\.md$|(^|/)VERSION$|(^|/)(package\.json|pyproject\.toml|Cargo\.toml)'

is_docline() {
  local line="$1" path="$2"
  if [[ "$path" =~ $docs_file_pat ]]; then return 0; fi
  [[ "$line" =~ ^[[:space:]]*# ]] && return 0
  [[ "$line" =~ ^[[:space:]]*// ]] && return 0
  [[ "$line" =~ ^[[:space:]]*/\* ]] && return 0
  [[ "$line" =~ ^[[:space:]]*\* ]] && return 0
  [[ "$line" =~ \"\"\"|\'\'\' ]] && return 0
  [[ "$line" =~ ^[[:space:]]*#{1,6}[[:space:]] ]] && return 0
  return 1
}
is_version_line() {
  local line="$1"
  [[ "$line" =~ version[[:space:]]*[:=][[:space:]]*\"?[0-9]+\.[0-9]+(\.[0-9]+)? ]] && return 0
  [[ "$line" =~ ^[[:space:]]*\-?[0-9]+\.[0-9]+\.[0-9]+[[:space:]]*$ ]] && return 0
  return 1
}

# Extract top-3 paths
readarray -t T3_PATHS < <(echo "$TOP3_LINES" | cut -f4-)

# Per-line category volumes for TOP-3: docs/tests/config/deps/version/code
declare -A vol_add vol_del
for k in docs tests config deps version code; do vol_add[$k]=0; vol_del[$k]=0; done

current=""
while IFS= read -r line; do
  if [[ "$line" =~ ^diff\ --git\ a/(.*)\ b/(.*) ]]; then
    current="${BASH_REMATCH[2]}"
    keep=false
    for p in "${T3_PATHS[@]}"; do [[ "$p" == "$current" ]] && keep=true && break; done
    $keep || current=""
    continue
  fi
  [[ -z "$current" ]] && continue
  [[ "$line" =~ ^(\+\+\+|\-\-\-) ]] && continue

  if [[ "$line" =~ ^\+ ]]; then
    content="${line:1}"
    if   [[ "$current" =~ $deps_file_pat ]]; then               ((vol_add[deps]+=1))
    elif [[ "$current" =~ $tests_file_pat ]]; then              ((vol_add[tests]+=1))
    elif [[ "$current" =~ $config_file_pat ]]; then             ((vol_add[config]+=1))
    elif is_docline "$content" "$current"; then                 ((vol_add[docs]+=1))
    elif [[ "$current" =~ $version_files_pat ]] && is_version_line "$content"; then ((vol_add[version]+=1))
    else                                                        ((vol_add[code]+=1))
    fi
  elif [[ "$line" =~ ^\- ]]; then
    content="${line:1}"
    if   [[ "$current" =~ $deps_file_pat ]]; then               ((vol_del[deps]+=1))
    elif [[ "$current" =~ $tests_file_pat ]]; then              ((vol_del[tests]+=1))
    elif [[ "$current" =~ $config_file_pat ]]; then             ((vol_del[config]+=1))
    elif is_docline "$content" "$current"; then                 ((vol_del[docs]+=1))
    elif [[ "$current" =~ $version_files_pat ]] && is_version_line "$content"; then ((vol_del[version]+=1))
    else                                                        ((vol_del[code]+=1))
    fi
  fi
done <<< "$PATCH"

# Aggregate top-3 stats + ratios
t3_add=0; t3_del=0
for k in docs tests config deps version code; do
  ((t3_add += vol_add[$k])); ((t3_del += vol_del[$k]))
done
t3_total=$((t3_add + t3_del))
ratio_t3=$(awk -v a="$t3_add" -v d="$t3_del" 'BEGIN{printf "%.2f",(a+1)/(d+1)}')

# status emphasis in top-3
cnt_A=0; cnt_D=0; cnt_R=0
for p in "${T3_PATHS[@]}"; do
  st="${STATUS_MAP[$p]:-M}"
  case "$st" in A) ((cnt_A++));; D) ((cnt_D++));; R) ((cnt_R++));; esac
done

# whitespace-only on staged diff?
ws=false; is_ws_only_cached && ws=true

# category sizes
share(){ local c="$1"; echo $(( vol_add[$c] + vol_del[$c] )); }
docs_n=$(share docs); tests_n=$(share tests); config_n=$(share config)
deps_n=$(share deps); version_n=$(share version); code_n=$(share code)

# ---- decide category -------------------------------------------------------
type="edit"; emoji="ðŸ“"

if $ws; then
  type="cleanup"; emoji="ðŸ§¹"
elif (( cnt_R >= 2 )); then
  type="rename"; emoji="ðŸ”"
elif (( cnt_D >= 2 )) && (( t3_add + t3_del <= 50 )); then
  type="remove"; emoji="ðŸ”¥"
elif (( cnt_A >= 2 )) && (( t3_add >= 10 )); then
  type="add"; emoji="âž•"
elif (( deps_n > 0 )) && (( deps_n >= tests_n + docs_n + config_n + code_n )); then
  type="deps"; emoji="ðŸ“¦"
elif (( config_n > 0 )) && (( config_n >= docs_n )) && (( config_n >= tests_n )) && (( config_n >= deps_n )) && (( config_n >= code_n/2 )); then
  type="config"; emoji="âš™ï¸"
elif (( version_n >= 3 )) && (( deps_n + config_n + docs_n + tests_n <= version_n*2 )); then
  type="version bump"; emoji="ðŸ”–"
elif (( tests_n > 0 )) && (( tests_n >= docs_n )) && (( tests_n >= config_n )) && (( tests_n >= deps_n )) && (( tests_n >= code_n/2 )); then
  type="tests"; emoji="âœ…"
elif (( docs_n > 0 )) && (( docs_n >= tests_n )) && (( docs_n >= config_n )) && (( docs_n >= deps_n )) && (( docs_n >= code_n/2 )); then
  type="docs"; emoji="ðŸ“š"
elif (( t3_total <= 3 )); then
  type="oneliner"; emoji="âš¡"
elif (( t3_total <= 20 )) && (( ${#T3_PATHS[@]} <= 3 )); then
  type="bugfix"; emoji="ðŸ›"
elif awk -v r="$ratio_t3" 'BEGIN{exit !(r>=3.0)}'; then
  type="feat"; emoji="âœ¨"
elif awk -v r="$ratio_t3" 'BEGIN{exit !(r<=0.33)}'; then
  type="prune"; emoji="ðŸ”¥"
elif awk -v r="$ratio_t3" 'BEGIN{exit !(r>=0.7 && r<=1.3)}' && (( t3_total > 1200 )); then
  type="rewrite"; emoji="ðŸ§¨"
elif awk -v r="$ratio_t3" 'BEGIN{exit !(r>=0.7 && r<=1.3)}' && (( t3_total > 300 )); then
  type="refactor"; emoji="â™»ï¸"
fi

[[ -n "$note" ]] && type="$type â€” $note"

suffix=" (+${TOTAL_ADDS}/-${TOTAL_DELS}, ${DATE})"
(( TOTAL_FILES > 3 )) && suffix="${suffix} (${TOTAL_FILES} files)"
msg="${emoji} ${type} â€” ${TOP3_FILES}${suffix}"

# ---- commit & print message ------------------------------------------------
git commit -a -m "$msg" >/dev/null
echo "$msg"

