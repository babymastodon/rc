#!/usr/bin/env bash
# git-commit-all: robust, concise auto-commit with emoji + smart category
# - Auto-adds modified/deleted tracked files (git add -u)
# - One-line: "<emoji> <type> â€” <top3 basenames> (+adds/-dels, YYYY-MM-DD HH:MM) [ (N files) ]"
# - Category from TOP-3 files using per-line volumes + add/remove ratio
# - HARD OVERRIDES:
#     * If any top-3 is deleted  -> ðŸ”¥ remove
#     * If any top-3 is renamed  -> ðŸ” rename
#     * If any top-3 is added    -> classify by extension (docs/tests/config/deps/version) else âœ¨ add
# - Soft categories: rewrite, docs, version bump, tests, config, deps, cleanup, add/remove/rename, refactor, feat, prune, bugfix, oneliner, edit

set -uo pipefail  # not using -e; explicit rc checks

note="${*:-}"
DEBUG=${GCA_DEBUG:-0}
log_debug(){ [[ "$DEBUG" = "1" ]] && echo "[gca] $*" >&2; }
die(){ echo "git-commit-all: $*" >&2; exit 1; }

in_repo(){ git rev-parse --show-toplevel >/dev/null 2>&1; }
is_ws_only_cached(){ git diff --cached -w --quiet; return $?; }
join_commas(){ awk 'BEGIN{ORS=""}{if(NR>1)printf(", ");printf("%s",$0)}END{print ""}'; }
basename_only(){ local p="$1"; p="${p%/}"; printf "%s\n" "${p##*/}"; }

# ---------- setup ----------
in_repo || die "not a git repo"
git add -u >/dev/null 2>&1 || true

if git diff --cached --quiet; then
  echo "Nothing to commit. (Tip: untracked files need 'git add <file>')" >&2
  exit 0
fi

NAME_STATUS="$(git diff --cached --name-status -M -C 2>/dev/null || true)"
NUMSTAT="$(git diff --cached --numstat -M -C 2>/dev/null || true)"
PATCH="$(git diff --cached 2>/dev/null || true)"

TOTAL_ADDS=$(printf "%s\n" "$NUMSTAT" | awk '{a=$1; if(a=="-"||a=="") a=0; s+=a} END{print s+0}')
TOTAL_DELS=$(printf "%s\n" "$NUMSTAT" | awk '{d=$2; if(d=="-"||d=="") d=0; s+=d} END{print s+0}')
TOTAL_FILES=$(printf "%s\n" "$NUMSTAT" | awk 'NF>=3{n++} END{print n+0}')
DATE=$(date +"%Y-%m-%d %H:%M")

TOP3_LINES=$(
  printf "%s\n" "$NUMSTAT" \
  | awk '{
      a=$1; d=$2; if(a=="-"||a=="") a=0; if(d=="-"||d=="") d=0;
      path=$3; for(i=4;i<=NF;i++){path=path OFS $i}
      if(path!=""){ print a+d "\t" a "\t" d "\t" path }
    }' \
  | sort -nr | head -3
)

# Build top-3 arrays (full + basename)
declare -a T3_PATHS=() T3_BASES=()
while IFS=$'\t' read -r _ch _a _d path || [[ -n "${path:-}" ]]; do
  [[ -z "${path:-}" ]] && continue
  T3_PATHS+=("$path")
  T3_BASES+=("$(basename_only "$path")")
done < <(printf "%s\n" "$TOP3_LINES")

if [[ ${#T3_PATHS[@]} -eq 0 ]]; then
  while IFS= read -r p; do
    [[ -z "$p" ]] && continue
    T3_PATHS+=("$p"); T3_BASES+=("$(basename_only "$p")")
  done < <(printf "%s\n" "$NUMSTAT" | awk '{p=$3; for(i=4;i<=NF;i++){p=p OFS $i} if(p!="") print p}' | head -3)
fi

TOP3_FILES=$(printf "%s\n" "${T3_BASES[@]}" | join_commas)
[[ -z "${TOP3_FILES:-}" ]] && TOP3_FILES="<no-paths>"

# Map file -> status (A/M/D/R/C)
declare -A STATUS_MAP
while IFS=$'\t' read -r s p1 p2 || [[ -n "${s:-}" ]]; do
  [[ -z "${s:-}" ]] && continue
  if [[ "$s" =~ ^R ]]; then STATUS_MAP["$p2"]="R"
  elif [[ "$s" =~ ^C ]]; then STATUS_MAP["$p2"]="C"
  else STATUS_MAP["$p1"]="${s:0:1}"
  fi
done < <(printf "%s\n" "$NAME_STATUS")

# ---------- patterns ----------
docs_file_pat='(^|/)docs?(/|$)|\.(md|rst|adoc|mdx|txt)$'
tests_file_pat='(^|/)(test|tests|__tests__|spec)(/|$)|\.(test|spec)\.[^/]+$'
config_file_pat='\.(json|ya?ml|toml|ini|conf|config)$|(^|/)\.(editorconfig|eslintrc(\.json)?|prettier(rc|\.config\.js)?|stylelintrc(\.json)?)$|(^|/)Makefile$|(^|/)Dockerfile$|(^|/)docker-compose\.ya?ml$|(^|/)pyproject\.toml$|(^|/)setup\.(cfg|py)$|(^|/)tsconfig\.json$'
deps_file_pat='(^|/)package(-lock)?\.json$|(^|/)yarn\.lock$|(^|/)pnpm-lock\.yaml$|(^|/)poetry\.lock$|(^|/)Pipfile(\.lock)?$|(^|/)Gemfile(\.lock)?$|(^|/)Cargo\.(lock|toml)$|(^|/)go\.(mod|sum)$|(^|/)composer\.(json|lock)$|(^|/)Podfile(\.lock)?$|(^|/)pom\.xml$|(^|/)build\.gradle(\.kts)?$'
version_files_pat='(^|/)CHANGELOG\.md$|(^|/)CHANGES\.md$|(^|/)VERSION$|(^|/)(package\.json|pyproject\.toml|Cargo\.toml)'

is_docline(){
  local line="$1" path="$2"
  [[ "$path" =~ $docs_file_pat ]] && return 0
  [[ "$line" =~ ^[[:space:]]*# ]] && return 0
  [[ "$line" =~ ^[[:space:]]*// ]] && return 0
  [[ "$line" =~ ^[[:space:]]*/\* ]] && return 0
  [[ "$line" =~ ^[[:space:]]*\* ]] && return 0
  [[ "$line" =~ \"\"\"|\'\'\' ]] && return 0
  [[ "$line" =~ ^[[:space:]]*#{1,6}[[:space:]] ]] && return 0
  return 1
}
is_version_line(){
  local line="$1"
  [[ "$line" =~ version[[:space:]]*[:=][[:space:]]*\"?[0-9]+\.[0-9]+(\.[0-9]+)? ]] && return 0
  [[ "$line" =~ ^[[:space:]]*\-?[0-9]+\.[0-9]+\.[0-9]+[[:space:]]*$ ]] && return 0
  return 1
}

# ---------- per-line volumes for top-3 ----------
declare -A vol_add vol_del
for k in docs tests config deps version code; do vol_add[$k]=0; vol_del[$k]=0; done

current=""
while IFS= read -r line || [[ -n "$line" ]]; do
  if [[ "$line" =~ ^diff\ --git\ a/(.*)\ b/(.*) ]]; then
    current="${BASH_REMATCH[2]}"
    keep=0; for p in "${T3_PATHS[@]:-}"; do [[ "$p" == "$current" ]] && keep=1 && break; done
    (( keep == 1 )) || current=""
    continue
  fi
  [[ -z "$current" ]] && continue
  [[ "$line" =~ ^(\+\+\+|\-\-\-) ]] && continue

  if [[ "$line" == +* ]]; then
    content="${line:1}"
    if   [[ "$current" =~ $deps_file_pat ]]; then               ((vol_add[deps]+=1))
    elif [[ "$current" =~ $tests_file_pat ]]; then              ((vol_add[tests]+=1))
    elif [[ "$current" =~ $config_file_pat ]]; then             ((vol_add[config]+=1))
    elif is_docline "$content" "$current"; then                 ((vol_add[docs]+=1))
    elif [[ "$current" =~ $version_files_pat ]] && is_version_line "$content"; then ((vol_add[version]+=1))
    else                                                        ((vol_add[code]+=1))
    fi
  elif [[ "$line" == -* ]]; then
    content="${line:1}"
    if   [[ "$current" =~ $deps_file_pat ]]; then               ((vol_del[deps]+=1))
    elif [[ "$current" =~ $tests_file_pat ]]; then              ((vol_del[tests]+=1))
    elif [[ "$current" =~ $config_file_pat ]]; then             ((vol_del[config]+=1))
    elif is_docline "$content" "$current"; then                 ((vol_del[docs]+=1))
    elif [[ "$current" =~ $version_files_pat ]] && is_version_line "$content"; then ((vol_del[version]+=1))
    else                                                        ((vol_del[code]+=1))
    fi
  fi
done <<< "$PATCH"

t3_add=0; t3_del=0
for k in docs tests config deps version code; do
  ((t3_add += vol_add[$k])); ((t3_del += vol_del[$k]))
done
t3_total=$((t3_add + t3_del))
if [[ $t3_add -eq 0 && $t3_del -eq 0 ]]; then ratio_t3="1.00"
else ratio_t3=$(awk -v a="$t3_add" -v d="$t3_del" 'BEGIN{printf "%.2f",(a+1)/(d+1)}'); fi

# ---------- status emphasis for top-3 (HARD OVERRIDES) ----------
cnt_A=0; cnt_D=0; cnt_R=0
declare -a T3_STATUS=()
for p in "${T3_PATHS[@]:-}"; do
  st="${STATUS_MAP[$p]:-M}"; T3_STATUS+=("$st")
  case "$st" in A) ((cnt_A++));; D) ((cnt_D++));; R) ((cnt_R++));; esac
done

# ---------- build a classification helper for new files ----------
class_for_added() {
  local path="$1"
  if   [[ "$path" =~ $deps_file_pat ]]; then echo "deps|ðŸ“¦"
  elif [[ "$path" =~ $tests_file_pat ]]; then echo "tests|âœ…"
  elif [[ "$path" =~ $docs_file_pat ]]; then  echo "docs|ðŸ“š"
  elif [[ "$path" =~ $config_file_pat ]]; then echo "config|âš™ï¸"
  elif [[ "$path" =~ $version_files_pat ]]; then echo "version bump|ðŸ”–"
  else echo "add|âœ¨"
  fi
}

# ---------- choose category ----------
type="edit"; emoji="ðŸ“"

# HARD OVERRIDES FIRST (as requested)
if (( cnt_D >= 1 )); then
  type="remove"; emoji="ðŸ”¥"
elif (( cnt_R >= 1 )); then
  type="rename"; emoji="ðŸ”"
elif (( cnt_A >= 1 )); then
  # If any of the top-3 is added, classify each added file; pick the most "specific" (non-generic) if present.
  add_choice="add|âœ¨"
  for i in "${!T3_PATHS[@]}"; do
    if [[ "${T3_STATUS[$i]}" == "A" ]]; then
      add_choice=$(class_for_added "${T3_PATHS[$i]}")
      # Prefer any of: deps/config/tests/docs/version bump over generic add
      IFS="|" read -r ctype cemoji <<< "$add_choice"
      if [[ "$ctype" != "add" ]]; then type="$ctype"; emoji="$cemoji"; break; fi
    fi
  done
  if [[ "$type" == "edit" ]]; then IFS="|" read -r type emoji <<< "$add_choice"; fi

else
  # SOFT logic (unchanged): cleanup â†’ deps/config/version/tests/docs â†’ small â†’ ratio â†’ rewrite/refactor â†’ prune/feat â†’ edit
  ws=false; is_ws_only_cached && ws=true
  share(){ local c="$1"; echo $(( vol_add[$c] + vol_del[$c] )); }
  docs_n=$(share docs); tests_n=$(share tests); config_n=$(share config)
  deps_n=$(share deps); version_n=$(share version); code_n=$(share code)

  if $ws; then
    type="cleanup"; emoji="ðŸ§¹"
  elif (( deps_n > 0 )) && (( deps_n >= tests_n + docs_n + config_n + code_n )); then
    type="deps"; emoji="ðŸ“¦"
  elif (( config_n > 0 )) && (( config_n >= docs_n )) && (( config_n >= tests_n )) && (( config_n >= deps_n )) && (( config_n >= code_n/2 )); then
    type="config"; emoji="âš™ï¸"
  elif (( version_n >= 3 )) && (( deps_n + config_n + docs_n + tests_n <= version_n*2 )); then
    type="version bump"; emoji="ðŸ”–"
  elif (( tests_n > 0 )) && (( tests_n >= docs_n )) && (( tests_n >= config_n )) && (( tests_n >= deps_n )) && (( tests_n >= code_n/2 )); then
    type="tests"; emoji="âœ…"
  elif (( docs_n > 0 )) && (( docs_n >= tests_n )) && (( docs_n >= config_n )) && (( docs_n >= deps_n )) && (( docs_n >= code_n/2 )); then
    type="docs"; emoji="ðŸ“š"
  elif (( t3_total <= 3 )); then
    type="oneliner"; emoji="âš¡"
  elif (( t3_total <= 20 )) && (( ${#T3_PATHS[@]} <= 3 )); then
    type="bugfix"; emoji="ðŸ›"
  elif awk -v r="$ratio_t3" 'BEGIN{exit !(r>=3.0)}'; then
    type="feat"; emoji="âœ¨"
  elif awk -v r="$ratio_t3" 'BEGIN{exit !(r<=0.33)}'; then
    type="prune"; emoji="ðŸ”¥"
  elif awk -v r="$ratio_t3" 'BEGIN{exit !(r>=0.7 && r<=1.3)}' && (( t3_total > 1200 )); then
    type="rewrite"; emoji="ðŸ§¨"
  elif awk -v r="$ratio_t3" 'BEGIN{exit !(r>=0.7 && r<=1.3)}' && (( t3_total > 300 )); then
    type="refactor"; emoji="â™»ï¸"
  fi
fi

[[ -n "$note" ]] && type="$type â€” $note"

suffix=" (+${TOTAL_ADDS}/-${TOTAL_DELS}, ${DATE})"
(( TOTAL_FILES > 3 )) && suffix="${suffix} (${TOTAL_FILES} files)"
msg="${emoji} ${type} â€” ${TOP3_FILES}${suffix}"

if [[ "$DEBUG" = "1" ]]; then
  echo "[gca] files=${TOTAL_FILES} adds=${TOTAL_ADDS} dels=${TOTAL_DELS} t3_add=${t3_add} t3_del=${t3_del} ratio=${ratio_t3}" >&2
  echo "[gca] status A=${cnt_A} D=${cnt_D} R=${cnt_R}" >&2
  echo "[gca] msg=${msg}" >&2
fi

if ! git commit -a -m "$msg" >/dev/null 2>&1; then
  echo "git-commit-all: git commit failed. Message was:" >&2
  echo "$msg" >&2
  exit 1
fi

echo "$msg"

