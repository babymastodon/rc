#!/usr/bin/env bash
# git-commit-all: auto-generate a smart commit message and run `git commit -a`.
# Usage:
#   git-commit-all [optional extra note...]
#
# Notes:
# - Uses `git commit -a` (tracks modified/deleted files; untracked files still
#   require `git add` first).
# - The message lists top 3 files by churn and "(total N files)" if N>3.
# - Heuristics consider add/remove ratio, churn, file count, renames, and file types.

set -euo pipefail
note="${*:-}"

die() { echo "git-commit-all: $*" >&2; exit 1; }
in_repo() { git rev-parse --show-toplevel >/dev/null 2>&1; }

# Check whitespace-only by ignoring whitespace diffs (working tree vs index).
is_whitespace_only() {
  set +e
  git diff -w --quiet
  local rc=$?
  set -e
  return $rc
}

join_with_commas() {
  awk 'BEGIN{ORS=""}{ if(NR>1) printf(", "); printf("%s",$0) } END{printf("\n")}'
}

count_grep() { grep -E -i -c -- "${1}" || true; }

in_repo || die "not inside a Git repository"

# Anything to commit with -a?
set +e
git diff --quiet
empty=$?
set -e
if [[ $empty -eq 0 ]]; then
  echo "Nothing to commit. (Tip: add new files with 'git add <file>')" >&2
  exit 0
fi

# --- Collect current (pre-commit) facts about unstaged tracked changes -------
# Compare working tree to index (this is what `-a` will stage automatically).
NAME_STATUS=$(git diff --name-status -M -C)
NUMSTAT=$(git diff --numstat -M -C)
PATCH=$(git diff)

# File lists
readarray -t CHANGED_FILES < <(echo "$NUMSTAT" | awk 'NF>=3 {print $3}')

TOTAL_FILES=$(echo "$NUMSTAT" | awk 'NF>=3{n++} END{print n+0}')
TOTAL_ADDS=$(echo "$NUMSTAT" | awk '{a=$1; if(a=="-") a=0; s+=a} END{print s+0}')
TOTAL_DELS=$(echo "$NUMSTAT" | awk '{d=$2; if(d=="-") d=0; s+=d} END{print s+0}')
TOTAL_CHURN=$(( TOTAL_ADDS + TOTAL_DELS ))

# Add/remove ratio (stable)
RATIO=$(awk -v a="$TOTAL_ADDS" -v d="$TOTAL_DELS" 'BEGIN{printf "%.3f", (a+1)/(d+1)}')

# Status counts
ADDS=$(echo "$NAME_STATUS" | awk '$1 ~ /^A/ {c++} END{print c+0}')
MODS=$(echo "$NAME_STATUS" | awk '$1 ~ /^M/ {c++} END{print c+0}')
DELS=$(echo "$NAME_STATUS" | awk '$1 ~ /^D/ {c++} END{print c+0}')
RENAMES=$(echo "$NAME_STATUS" | awk '$1 ~ /^R/ {c++} END{print c+0}')
COPIES=$(echo "$NAME_STATUS" | awk '$1 ~ /^C/ {c++} END{print c+0}')

# Top 3 files by churn
TOP3=$(echo "$NUMSTAT" \
  | awk '{a=$1; if(a=="-") a=0; d=$2; if(d=="-") d=0; c=a+d; $1=$2=""; sub(/^[ \t]+/,""); print c "\t" $0}' \
  | sort -nr \
  | head -3 \
  | cut -f2-)
TOP3_JOINED=$(echo "$TOP3" | join_with_commas)

# Patterns
docs_pat='(^|/)docs?(/|$)|\.(md|rst|adoc|mdx)$'
tests_pat='(^|/)(test|tests|__tests__|spec)(/|$)|\.(test|spec)\.[^/]+$'
cfg_pat='\.(json|ya?ml|toml|ini|conf|config)$|(^|/)\.(editorconfig|eslintrc(\.json)?|prettier(rc|\.config\.js)?|stylelintrc(\.json)?)$|(^|/)Makefile$|(^|/)Dockerfile$|(^|/)docker-compose\.ya?ml$|(^|/)pyproject\.toml$|(^|/)setup\.(cfg|py)$|(^|/)tsconfig\.json$'
pkg_pat='(^|/)package\.json$|(^|/)requirements(-dev)?\.txt$|(^|/)pyproject\.toml$|(^|/)Pipfile$|(^|/)Gemfile$|(^|/)Cargo\.toml$|(^|/)go\.mod$|(^|/)pom\.xml$|(^|/)build\.gradle(\.kts)?$|(^|/)Chart\.yaml$'
lock_pat='(^|/)package-lock\.json$|(^|/)yarn\.lock$|(^|/)pnpm-lock\.yaml$|(^|/)poetry\.lock$|(^|/)Pipfile\.lock$|(^|/)Gemfile\.lock$|(^|/)Cargo\.lock$|(^|/)go\.sum$|(^|/)composer\.lock$|(^|/)Podfile\.lock$'
release_files_pat='(^|/)CHANGELOG\.md$|(^|/)CHANGES\.md$|(^|/)VERSION$|(^|/)version\.txt$|(^|/)Cargo\.toml$|(^|/)pyproject\.toml$|(^|/)package\.json$'

FILES_JOINED=$(printf "%s\n" "${CHANGED_FILES[@]}")

DOCS_COUNT=$(printf "%s\n" "$FILES_JOINED" | count_grep "$docs_pat")
TESTS_COUNT=$(printf "%s\n" "$FILES_JOINED" | count_grep "$tests_pat")
CFG_COUNT=$(printf "%s\n" "$FILES_JOINED" | count_grep "$cfg_pat")
PKG_COUNT=$(printf "%s\n" "$FILES_JOINED" | count_grep "$pkg_pat")
LOCK_COUNT=$(printf "%s\n" "$FILES_JOINED" | count_grep "$lock_pat")

# Content cues
SECURITY_FIX=false
echo "$PATCH" | grep -E -i -q '(^|\b)(CVE-|security|vulnerab)' && SECURITY_FIX=true

PERF_HINT=false
echo "$PATCH" | grep -E -i -q '(^|\+).*O\(|(^|\b)perf|optimi[sz]e' && PERF_HINT=true

WHITESPACE_ONLY=false
is_whitespace_only && WHITESPACE_ONLY=true

version_line_changed=$(echo "$PATCH" | grep -E -i -c '^[\+\-].{0,30}"?version"?[": ]' || true)
RELEASE_BUMP=false
if [[ $DOCS_COUNT -eq 0 && $TESTS_COUNT -eq 0 ]]; then
  if [[ $LOCK_COUNT -eq 0 ]] && [[ $PKG_COUNT -gt 0 ]] && [[ ${version_line_changed:-0} -gt 0 ]]; then
    RELEASE_BUMP=true
  fi
  # classic changelog/version files
  if printf "%s\n" "$FILES_JOINED" | grep -E -q "$release_files_pat"; then
    RELEASE_BUMP=true
  fi
fi

# Helpers
only_files_match() {
  local pat="$1"
  local total=$(printf "%s\n" "$FILES_JOINED" | sed '/^$/d' | wc -l | tr -d ' ')
  [[ "$total" -gt 0 ]] || return 1
  local matched=$(printf "%s\n" "$FILES_JOINED" | grep -E -i -c -- "$pat" || true)
  [[ "${matched:-0}" -eq "$total" ]]
}

# --- Decide category (priority order) ---------------------------------------
type="edit"; desc="general edits"

if $WHITESPACE_ONLY; then
  type="cleanup"; desc="whitespace/formatting"
elif (( LOCK_COUNT + PKG_COUNT > 0 )) && only_files_match "(${lock_pat})|(${pkg_pat})"; then
  type="deps"; desc="update dependencies"
elif $RELEASE_BUMP; then
  type="release"; desc="version/changelog bump"
elif $SECURITY_FIX; then
  type="security"; desc="security fix"
elif (( RENAMES > 0 )) && (( TOTAL_CHURN < 500 )) && (( TOTAL_FILES <= 20 )); then
  type="rename"; desc="rename/move files"
elif only_files_match "$docs_pat"; then
  type="docs"; desc="update docs"
elif only_files_match "$tests_pat"; then
  type="tests"; desc="update tests"
elif only_files_match "$cfg_pat"; then
  type="config"; desc="config tweaks"
elif (( TOTAL_CHURN <= 3 )); then
  type="oneliner"; desc="one-liner change"
elif (( TOTAL_FILES <= 3 )) && (( TOTAL_CHURN <= 20 )); then
  type="fix"; desc="bug fix"
# Ratio-driven decisions:
elif awk -v r="$RATIO" 'BEGIN{exit !(r>=3.0)}'; then
  type="feat"; desc="implement/expand feature"
elif awk -v r="$RATIO" 'BEGIN{exit !(r<=0.333)}'; then
  type="slimdown"; desc="remove dead code/prune"
# Large balanced churn (near rewrite/refactor)
elif { (( TOTAL_FILES >= 5 )) && (( TOTAL_CHURN >= 400 )) && awk -v r="$RATIO" 'BEGIN{exit !(r>=0.67 && r<=1.5)}'; }; then
  type="refactor"; desc="major refactor"
elif $PERF_HINT; then
  type="perf"; desc="performance improvements"
else
  type="edit"; desc="general edits"
fi

# --- Build commit message ----------------------------------------------------
files_part="$TOP3_JOINED"
[[ -z "$files_part" ]] && files_part=$(printf "%s\n" "${CHANGED_FILES[@]}" | head -3 | join_with_commas)

suffix=""
(( TOTAL_FILES > 3 )) && suffix=" (total ${TOTAL_FILES} files)"

extra=""
[[ -n "$note" ]] && extra=" — $note"

short="${type}: ${desc}"
msg="$short — $files_part$suffix$extra"

# Body: quick stats (adds/dels and ratio)
body=$(printf "adds:%d dels:%d ratio:%s" "$TOTAL_ADDS" "$TOTAL_DELS" "$RATIO")

# --- Commit (with -a as requested) -----------------------------------------
git commit -a -m "$msg" -m "$body"

