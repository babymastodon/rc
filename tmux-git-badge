#!/usr/bin/env bash
# tmux-git-badge — fast Git status for tmuxW
#   - If CWD changed → rebuild Git string
#   - Check HEAD for changes every 5 seconds
#   - Else reuse cached output for up to 60s
#   - Assumes that Vim clears cache upon each save

set -euo pipefail

pane_id="${2:-${TMUX_PANE:-no_pane}}"
cache="/tmp/tmux-git-badge.${pane_id}"
CWD=${1:-$PWD}
now=${EPOCHSECONDS:-$(date +%s)}

# Read cache and check for changes
if { exec {fd}<"$cache"; } 2>/dev/null; then
  IFS= read -r -u "$fd" cwd_cached  || cwd_cached=""
  IFS= read -r -u "$fd" last_check  || last_check=0

  if [[ $cwd_cached == "$CWD" ]]; then
    # Always return cache for up to 5 sec
    if (( now - last_check <= 5)); then
      IFS= read -r -u "$fd" out || out=""
      exec {fd}<&-
      [[ -n $out ]] && printf '%s\n' "$out"
      exit 0
    fi

    IFS= read -r -u "$fd" out  || out=""
    IFS= read -r -u "$fd" head || head="_"
    IFS= read -r -u "$fd" last_regen || last_regen="0"
    exec {fd}<&-

    # For up to 60s, always return cache if HEAD unchanged
    if (( now - last_regen < 60)); then
      if  [[ $head == "_" ]]; then
        [[ -n $out ]] && printf '%s\n' "$out"
        exit 0
      fi
      cur="$(git -C "$CWD" rev-parse --verify --short=12 HEAD 2>/dev/null || printf '_')"
      if [[ $cur == "$head" ]]; then
        tmp="${cache}.tmp.$$"
        {
          printf '%s\n' "$cwd_cached"   # [1] cwd
          printf '%s\n' "$now"          # [2] last_head_check (updated)
          printf '%s\n' "$out"          # [3] out (unchanged)
          printf '%s\n' "$head"         # [4] head (unchanged)
          printf '%s\n' "$last_regen"   # [5] ts (unchanged)
          printf '\n'                   # [6] reserved
        } >"$tmp"
        mv "$tmp" "$cache"
        [[ -n $out ]] && printf '%s\n' "$out"
        exit 0
      fi
    fi
  else
    exec {fd}<&-
  fi
fi

# ---------- REGEN PATH (no cache / CWD changed / stale / HEAD moved) ----------
# Non-git repo → cache empty badge and throttle future checks
if ! git -C "$CWD" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
  tmp="${cache}.tmp.$$"
  {
    printf '%s\n' "$CWD"  # [1] cwd
    printf '%s\n' "$now"  # [2] last_head_check
    printf '\n'           # [3] out (empty)
    printf '_\n'          # [4] head placeholder
    printf '%s\n' "$now"  # [5] ts (unused)
    printf '\n'           # [6] reserved
  } >"$tmp"
  mv "$tmp" "$cache"
  exit 0
fi

# ---------- gather git info (full rebuild) ----------
top="$(git -C "$CWD" rev-parse --show-toplevel 2>/dev/null || printf '%s' "$CWD")"
repo="${top##*/}"
branch="$(git -C "$CWD" symbolic-ref --short -q HEAD 2>/dev/null || git -C "$CWD" rev-parse --short HEAD 2>/dev/null || printf '?')"
ahead="$(git -C "$CWD" rev-list --count @{u}..HEAD 2>/dev/null || printf 0)"
behind="$(git -C "$CWD" rev-list --count HEAD..@{u} 2>/dev/null || printf 0)"
head_short="$(git -C "$CWD" rev-parse --verify --short=12 HEAD 2>/dev/null || printf '-')"

clean_mark=""
if git -C "$CWD" diff --quiet --ignore-submodules HEAD 2>/dev/null; then clean_mark=" ✓"; fi

sum_numstat() { awk '$1 ~ /^[0-9]+$/ {i+=$1} $2 ~ /^[0-9]+$/ {d+=$2} END {print (i+0), (d+0)}'; }
read -r i1 d1 <<<"$(git -C "$CWD" diff --numstat 2>/dev/null | sum_numstat)"
read -r i2 d2 <<<"$(git -C "$CWD" diff --numstat --cached 2>/dev/null | sum_numstat)"
ins=$((i1 + i2)); del=$((d1 + d2))

out="  $branch"
(( ahead > 0 ))  && out+=" ↑$ahead"
(( behind > 0 )) && out+=" ↓$behind"
out+=" ($repo)$clean_mark"
if (( ins > 0 || del > 0 )); then out+=" [+$ins -$del]"; fi

# ---------- write cache (order: cwd, last, out, head, ts, reserved) ----------
tmp="${cache}.tmp.$$"
{
  printf '%s\n' "$CWD"        # [1] cwd
  printf '%s\n' "$now"        # [2] last_head_check = now
  printf '%s\n' "$out"        # [3] out
  printf '%s\n' "$head_short" # [4] head
  printf '%s\n' "$now"        # [5] ts (not used for decisions)
  printf '\n'                 # [6] reserved
} >"$tmp"
mv "$tmp" "$cache"

printf '%s\n' "$out"

