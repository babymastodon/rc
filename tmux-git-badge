#!/usr/bin/env bash
# shellcheck disable=SC2155 # allow inline decls
set -euo pipefail

TTL=20  # seconds before regeneration

# ---------- inputs ----------
pane_id="${2:-${TMUX_PANE:-no_pane}}"
cache="/tmp/tmux-git-badge.${pane_id}"

# ---------- resolve CWD ----------
CWD=""
if (( $# >= 1 )) && [[ -n "${1:-}" && -d "$1" ]]; then
  CWD=$1
fi
: "${CWD:=${PWD:-/}}"

now=${EPOCHSECONDS:-$(date +%s)}  # falls back only if not Bash 5

# ---------- fast path ----------
if [[ -s $cache ]]; then
  # Open once; read exactly 3 lines
  exec {fd}<"$cache"
  mapfile -t -n 3 lines <&"$fd" || true
  exec {fd}<&-
  ts=${lines[0]:-0}
  cached_cwd=${lines[1]:-}
  cached_out=${lines[2]:-}


  if [[ $cached_cwd == "$CWD" ]] && (( now - ts < TTL )); then
    # ðŸš€ non-git fast path: print nothing if empty
    [[ -n $cached_out ]] && printf '%s\n' "$cached_out"
    exit 0
  fi
fi

# ---------- not a git repo? cache empty + exit ----------
if ! git -C "$CWD" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
  tmp="${cache}.tmp.$$"
  { printf '%s\n' "$now"; printf '%s\n' "$CWD"; printf '\n'; } >"$tmp"
  mv "$tmp" "$cache"
  exit 0
fi

# ---------- gather git info ----------
top="$(git -C "$CWD" rev-parse --show-toplevel 2>/dev/null || printf '%s' "$CWD")"
repo="${top##*/}"
branch="$(git -C "$CWD" symbolic-ref --short -q HEAD 2>/dev/null || git -C "$CWD" rev-parse --short HEAD 2>/dev/null || printf '?')"
ahead="$(git -C "$CWD" rev-list --count @{u}..HEAD 2>/dev/null || printf 0)"
behind="$(git -C "$CWD" rev-list --count HEAD..@{u} 2>/dev/null || printf 0)"

# clean flag (âœ“ only)
clean_mark=""
if git -C "$CWD" diff --quiet --ignore-submodules HEAD 2>/dev/null; then
  clean_mark=" âœ“"
fi

# accurate added/removed counts (staged + unstaged)
sum_numstat() {
  awk '$1 ~ /^[0-9]+$/ {i+=$1} $2 ~ /^[0-9]+$/ {d+=$2} END {print (i+0), (d+0)}'
}
read -r i1 d1 <<<"$(git -C "$CWD" diff --numstat 2>/dev/null | sum_numstat)"
read -r i2 d2 <<<"$(git -C "$CWD" diff --numstat --cached 2>/dev/null | sum_numstat)"
ins=$((i1 + i2))
del=$((d1 + d2))

# ---------- build output ----------
out=" î‚  $branch"
(( ahead > 0 ))  && out+=" â†‘$ahead"
(( behind > 0 )) && out+=" â†“$behind"
out+=" ($repo)$clean_mark"
if (( ins > 0 || del > 0 )); then
  out+=" [+$ins -$del]"
fi

# ---------- write cache ----------
tmp="${cache}.tmp.$$"
{ printf '%s\n' "$now"; printf '%s\n' "$CWD"; printf '%s\n' "$out"; } >"$tmp"
mv "$tmp" "$cache"

printf '%s\n' "$out"

