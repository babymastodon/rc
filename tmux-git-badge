#!/usr/bin/env bash
# tmux-git-badge — fast Git status for tmux (MED + SLOW TTLs only).
# Each run:
#   - If CWD changed → rebuild.
#   - Else if >5s since last HEAD check → one HEAD check; if unchanged, bump timestamp; else rebuild.
#   - Else reuse cached output (no Git).
# Cache lines (6): [1] cwd, [2] last_head_check, [3] out, [4] head, [5] ts (unused), [6] reserved.
# Note: Because last_head_check is always >= ts, we never need to read/compare ts on fast/med paths.

set -euo pipefail

MED_TTL=5      # HEAD check interval
SLOW_TTL=60    # max reuse window; enforced against last_head_check

# ---------- inputs ----------
pane_id="${2:-${TMUX_PANE:-no_pane}}"
cache="/tmp/tmux-git-badge.${pane_id}"

# ---------- resolve CWD ----------
CWD=""
if (( $# >= 1 )) && [[ -n "${1:-}" && -d "$1" ]]; then CWD=$1; fi
: "${CWD:=${PWD:-/}}"

now=${EPOCHSECONDS:-$(date +%s)}

# ---------- FAST + MED PATHS (min I/O & commands; never read ts) ----------
if exec {fd}<"$cache"; then
  IFS= read -r -u "$fd" cwd_cached  || cwd_cached=""
  IFS= read -r -u "$fd" last_check  || last_check=0

  if [[ $cwd_cached == "$CWD" ]]; then
    # FAST reuse (within MED_TTL): read only 'out' and return (no git, no ts)
    if (( now - last_check <= MED_TTL )); then
      IFS= read -r -u "$fd" out || out=""
      exec {fd}<&-
      [[ -n $out ]] && printf '%s\n' "$out"
      exit 0
    fi

    # Due to check: read 'out' and 'head' (skip ts), then single HEAD probe.
    IFS= read -r -u "$fd" out  || out=""
    IFS= read -r -u "$fd" head || head="-"
    # skip reading ts (line 5) entirely — it’s redundant
    exec {fd}<&-

    # If head is unchanged within SLOW_TTL, return cache
    if (( now - last_check < SLOW_TTL )); then
      cur="$(git -C "$CWD" rev-parse --verify --short=12 HEAD 2>/dev/null || printf '-')"
      if [[ $cur == "$head" ]]; then
        # HEAD unchanged → update only last_head_check and reuse cached out.
        tmp="${cache}.tmp.$$"
        {
          printf '%s\n' "$cwd_cached"   # [1] cwd
          printf '%s\n' "$now"          # [2] last_head_check (updated)
          printf '%s\n' "$out"          # [3] out (unchanged)
          printf '%s\n' "$head"         # [4] head (unchanged)
          printf '%s\n' "$now"          # [5] ts (keep monotonic; not used for decisions)
          printf '\n'                   # [6] reserved
        } >"$tmp"
        mv "$tmp" "$cache"
        [[ -n $out ]] && printf '%s\n' "$out"
        exit 0
      fi
    fi
  else
    exec {fd}<&-
  fi
fi

# ---------- REGEN PATH (no cache / CWD changed / stale / HEAD moved) ----------
# Non-git repo → cache empty badge and throttle future checks
if ! git -C "$CWD" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
  tmp="${cache}.tmp.$$"
  {
    printf '%s\n' "$CWD"  # [1] cwd
    printf '%s\n' "$now"  # [2] last_head_check
    printf '\n'           # [3] out (empty)
    printf '-\n'          # [4] head placeholder
    printf '%s\n' "$now"  # [5] ts (unused)
    printf '\n'           # [6] reserved
  } >"$tmp"
  mv "$tmp" "$cache"
  exit 0
fi

# ---------- gather git info (full rebuild) ----------
top="$(git -C "$CWD" rev-parse --show-toplevel 2>/dev/null || printf '%s' "$CWD")"
repo="${top##*/}"
branch="$(git -C "$CWD" symbolic-ref --short -q HEAD 2>/dev/null || git -C "$CWD" rev-parse --short HEAD 2>/dev/null || printf '?')"
ahead="$(git -C "$CWD" rev-list --count @{u}..HEAD 2>/dev/null || printf 0)"
behind="$(git -C "$CWD" rev-list --count HEAD..@{u} 2>/dev/null || printf 0)"
head_short="$(git -C "$CWD" rev-parse --verify --short=12 HEAD 2>/dev/null || printf '-')"

clean_mark=""
if git -C "$CWD" diff --quiet --ignore-submodules HEAD 2>/dev/null; then clean_mark=" ✓"; fi

sum_numstat() { awk '$1 ~ /^[0-9]+$/ {i+=$1} $2 ~ /^[0-9]+$/ {d+=$2} END {print (i+0), (d+0)}'; }
read -r i1 d1 <<<"$(git -C "$CWD" diff --numstat 2>/dev/null | sum_numstat)"
read -r i2 d2 <<<"$(git -C "$CWD" diff --numstat --cached 2>/dev/null | sum_numstat)"
ins=$((i1 + i2)); del=$((d1 + d2))

out="  $branch"
(( ahead > 0 ))  && out+=" ↑$ahead"
(( behind > 0 )) && out+=" ↓$behind"
out+=" ($repo)$clean_mark"
if (( ins > 0 || del > 0 )); then out+=" [+$ins -$del]"; fi

# ---------- write cache (order: cwd, last, out, head, ts, reserved) ----------
tmp="${cache}.tmp.$$"
{
  printf '%s\n' "$CWD"        # [1] cwd
  printf '%s\n' "$now"        # [2] last_head_check = now
  printf '%s\n' "$out"        # [3] out
  printf '%s\n' "$head_short" # [4] head
  printf '%s\n' "$now"        # [5] ts (not used for decisions)
  printf '\n'                 # [6] reserved
} >"$tmp"
mv "$tmp" "$cache"

printf '%s\n' "$out"

